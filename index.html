<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #d8d4c7; /* Softer, slightly vintage background */
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden; /* Prevent body scroll */
        }
        
        .stick-shadow {
            /* Classic offset shadow that worked well with top-left positioning */
            filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.2));
        }
        
        .slot-dash {
            border: 2px dashed rgba(0,0,0,0.15);
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }

        .paper-texture {
            background-image: radial-gradient(#a39e93 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Helpers ---
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        // --- Configuration (CLASSIC TOP-LEFT PIVOT) ---
        // Sticks are 80x10. Pivot is at 5px 5px.
        
        const SEG_TOP = [20, 0, 0];
        const SEG_TL  = [10, 20, 90];
        const SEG_TR  = [90, 20, 90];
        const SEG_MID = [20, 80, 0];
        const SEG_BL  = [10, 100, 90];
        const SEG_BR  = [90, 100, 90];
        const SEG_BOT = [20, 160, 0];

        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] 
        };

        const SEGMENT_POSITIONS = [
            SEG_TOP, SEG_TL, SEG_TR, SEG_MID, SEG_BL, SEG_BR, SEG_BOT
        ];

        // Operators
        const OP_PLUS = [
            [40, 50, 90], // Vertical
            [10, 80, 0]   // Horizontal
        ];
        const OP_MINUS = [[10, 80, 0]];
        const OP_EQUAL = [[10, 65, 0], [10, 95, 0]];

        // --- VALIDATION HELPER ---
        const checkMath = (values, ops) => {
            if (values.length === 3 && ops.length === 1) {
                const res = ops[0] === '+' ? values[0] + values[1] : values[0] - values[1];
                return res === values[2];
            } 
            return false;
        };

        // --- COORDINATE CONVERSION FOR SHAPES ---
        // Convert "Center Geometry" to "Top-Left Pivot (5,5)" Geometry
        // Stick Length 80. Center is at local (40, 5). Pivot at (5, 5).
        // Vector from Pivot to Center is (35, 0) in local stick space.
        // Rotated Vector: dx = 35 * cos(r), dy = 35 * sin(r).
        // Center (cx, cy) = Pivot (px, py) + (dx, dy)
        // => Pivot (px, py) = Center (cx, cy) - (dx, dy)
        const centerToPivot = (cx, cy, r) => {
            const rad = r * Math.PI / 180;
            return {
                x: cx - 35 * Math.cos(rad),
                y: cy - 35 * Math.sin(rad),
                r: r
            };
        };

        // Reuse precise shape centers from previous step, but convert them for the engine
        const SL = 80;
        const DIAG = 56; // 80*sin(45)
        
        // Define shapes using CENTERS first (easier geometry), then convert
        const FISH_CENTERS = [
            // Body Diamond (Center approx 400, 150)
            {cx:400, cy:100, r:45}, {cx:400+DIAG, cy:100+DIAG, r:135},
            {cx:400, cy:100+2*DIAG, r:225}, {cx:400-DIAG, cy:100+DIAG, r:315},
            // Tail
            {cx:400+DIAG, cy:100+DIAG, r:315}, {cx:400+DIAG, cy:100+DIAG, r:45},
            // Fins
            {cx:400, cy:100, r:225}, {cx:400, cy:100+2*DIAG, r:135}
        ];

        // POOLS
        const POOL_MATH = [
            {
                id: 'm1', type: 'math', title: "ç†±èº«é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 5 = 8",
                hint1: "8 ä¸éœ€è¦è®Šå‹•ï¼Œè©¦è‘—æ”¹è®Šå…¶ä¸­ä¸€å€‹ 5ã€‚", hint2: "æŠŠç¬¬ä¸€å€‹ 5 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 3ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm2', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 + 3 = 6",
                hint1: "å˜—è©¦æŠŠ 9 è®Šå°ã€‚", hint2: "æŠŠ 9 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ° 6 çš„ç¼ºå£ï¼Œè®“å®ƒè®Šæˆ 8ã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 3, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 6, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm3', type: 'math', title: "ç¶“å…¸é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "6 + 4 = 4",
                hint1: "é€™é¡Œæœ‰å¤šå€‹è§£æ³•ï¼è©¦è©¦æŠŠåŠ è™Ÿè®Šæ¸›è™Ÿï¼Ÿ", hint2: "è§£æ³•ä¸€ï¼š8 - 4 = 4ã€‚è§£æ³•äºŒï¼š0 + 4 = 4ã€‚",
                layout: [{ type: 'digit', value: 6, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 4, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 4, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm4', type: 'math', title: "æ•¸å­—è®Šèº«", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 - 5 = 8", 
                hint1: "æ¸›æ³•è®ŠåŠ æ³•ï¼Ÿ", hint2: "æŠŠ 9 è®Šæˆ 3ï¼Œæ¸›è™Ÿè®ŠåŠ è™Ÿã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '-', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm5', type: 'math', title: "æ¸›æ³•æŒ‘æˆ°", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 7 = 2",
                hint1: "åŠ æ³•è®Šæ¸›æ³•ï¼Ÿ", hint2: "æŠŠåŠ è™Ÿçš„ä¸€æ ¹ç«æŸ´ç§»åˆ° 5 ä¸Šï¼Œè®“å®ƒè®Šæˆ 9ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 7, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 2, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm6', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "3 + 6 = 3",
                hint1: "è©¦è©¦çœ‹ 3 åŠ  0ã€‚", hint2: "æŠŠ 6 è®Šæˆ 0ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 6, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 3, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            }
        ];

        const POOL_SHAPE = [
            {
                id: 's1', type: 'shape', title: "æ¸¸å‹•çš„å°é­š", instruction: "ç§»å‹• 3 æ ¹ç«æŸ´ï¼Œè®“é­šå‘åæ–¹å‘æ¸¸",
                formula: "åœ–å½¢é¡Œ",
                hint1: "é­šé ­ç¾åœ¨å‘å·¦ï¼Œè¦æŠŠå®ƒè®Šå‘å³ã€‚", hint2: "ç§»å‹•é­šé°­å’Œä¸‹åŠéƒ¨çš„èº«é«”ã€‚",
                customSticks: FISH_CENTERS.map(c => centerToPivot(c.cx, c.cy, c.r)),
                winSlots: FISH_CENTERS.map(c => centerToPivot(c.cx, c.cy, c.r)), // Simplified win check for same shape logic
                validSlots: [
                    ...FISH_CENTERS.map(c => centerToPivot(c.cx, c.cy, c.r)), // Current
                    // Mirror for solution (Fish Right)
                    // Simplified: just providing ample valid slots
                    ...FISH_CENTERS.map(c => centerToPivot(c.cx + 20, c.cy, 360-c.r)) // Approximate mirror
                ]
            },
            // Arrows: > >
            {
                id: 's2', type: 'shape', title: "å…©å€‹ç®­é ­", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠå…©å€‹ç®­é ­è®Šæˆä¸€å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "å°‡å…©å€‹ç®­é ­çš„å°¾éƒ¨é€£èµ·ä¾†ã€‚", hint2: "é€™æ˜¯ä¸€å€‹è¦–éŒ¯è¦ºï¼Œä¸éœ€è¦å®Œç¾çš„æ­£æ–¹å½¢ï¼Œé•·æ–¹å½¢(Box)ä¹Ÿå¯ä»¥ã€‚",
                customSticks: [
                    // Arrow 1 (Left) Center approx 220, 120
                    centerToPivot(220, 100, 45), centerToPivot(220, 100+DIAG*2, 315),
                    // Arrow 2 (Right)
                    centerToPivot(300, 100, 45), centerToPivot(300, 100+DIAG*2, 315)
                ],
                winSlots: [
                    // Box
                    centerToPivot(260, 100+DIAG/2, 0), centerToPivot(260, 100+1.5*DIAG, 0),
                    centerToPivot(220, 100+DIAG, 90), centerToPivot(300, 100+DIAG, 90)
                ],
                validSlots: [] // Will be auto-populated
            },
            {
                id: 's3', type: 'shape', title: "ä¸‰å€‹æ­£æ–¹å½¢", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠä¸‰å€‹æ­£æ–¹å½¢è®Šæˆå…©å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "è©¦è‘—æŠŠä¸­é–“çš„æ­£æ–¹å½¢æ‹†æ‰ã€‚", hint2: "æŠŠä¸­é–“æ­£æ–¹å½¢çš„å…©æ ¹ç›´ç«æŸ´æ‹¿èµ°ï¼Œæ”¾åˆ°å“ªè£¡å‘¢ï¼Ÿè£œä¸Šç¼ºå£ã€‚",
                // Grid: 80px. Start 100,100.
                customSticks: [
                    // Top: 140, 220, 300
                    centerToPivot(140, 100, 0), centerToPivot(220, 100, 0), centerToPivot(300, 100, 0),
                    // Bot: 140, 220, 300
                    centerToPivot(140, 180, 0), centerToPivot(220, 180, 0), centerToPivot(300, 180, 0),
                    // Verts: 100, 180, 260, 340
                    centerToPivot(100, 140, 90), centerToPivot(180, 140, 90), centerToPivot(260, 140, 90), centerToPivot(340, 140, 90)
                ],
                winSlots: [
                    // Left Square
                    centerToPivot(140, 100, 0), centerToPivot(140, 180, 0), centerToPivot(100, 140, 90), centerToPivot(180, 140, 90),
                    // Right Square
                    centerToPivot(380, 100, 0), centerToPivot(380, 180, 0), centerToPivot(340, 140, 90), centerToPivot(420, 140, 90)
                ],
                validSlots: []
            }
        ];

        const POOL_SPECIAL = [
            {
                id: 'sp1', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸€)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "26 + 4 = 20",
                hint1: "æŠŠç­”æ¡ˆ 20 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 20 çš„å·¦ä¸‹è§’ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 2, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 4, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 2, x: 510 }, { type: 'digit', value: 0, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) + values[2] === 30
            },
            {
                id: 'sp2', type: 'math', title: "ä¸‰åè€Œç«‹ (äºŒ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "36 - 6 = 36",
                hint1: "æŠŠç­”æ¡ˆ 36 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 6, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 'sp3', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸‰)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "35 - 5 = 39",
                hint1: "35 æ¸› 5 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 39 çš„ 9 è®Šæˆ 0ã€‚ç§»å‹• 9 çš„ä¸­é–“ç«æŸ´åˆ°å·¦ä¸‹è§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 5, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 9, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp4', type: 'math', title: "ä¸‰åè€Œç«‹ (å››)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "39 - 9 = 36",
                hint1: "39 æ¸› 9 ç­‰æ–¼ 30ã€‚", hint2: "æŠŠçµæœ 36 çš„ 6 è®Šæˆ 0ã€‚ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 9, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 9, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp5', type: 'math', title: "ä¸‰åé€±å¹´ (çµ‚æ¥µ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "15 + 15 = 50",
                hint1: "15 + 15 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 50 çš„ 5 è®Šæˆ 3ã€‚ç§»å‹•å·¦ä¸Šè§’çš„ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 1, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 1, x: 310 }, { type: 'digit', value: 5, x: 410 }, { type: 'op', value: '=', x: 530 }, { type: 'digit', value: 5, x: 610 }, { type: 'digit', value: 0, x: 710 }],
                check: (values) => values.length === 6 && (values[0]*10 + values[1]) + (values[2]*10 + values[3]) === 30
            }
        ];

        const generateLevelSet = () => {
            const math = shuffleArray(POOL_MATH).slice(0, 4);
            const shape = shuffleArray(POOL_SHAPE).slice(0, 2);
            const special = shuffleArray(POOL_SPECIAL).slice(0, 4);
            return [...math, ...shape, ...special];
        };

        const calculateBounds = (items) => {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            items.forEach(item => {
                // Approximate bounding box for stick based on pivot
                // Stick goes from (x,y) to (x+80*cos, y+80*sin) roughly
                const rad = item.r * Math.PI / 180;
                const x2 = item.x + 80 * Math.cos(rad);
                const y2 = item.y + 80 * Math.sin(rad);
                minX = Math.min(minX, item.x, x2);
                maxX = Math.max(maxX, item.x, x2);
                minY = Math.min(minY, item.y, y2);
                maxY = Math.max(maxY, item.y, y2);
            });
            return { minX, maxX, minY, maxY };
        };

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = [];
            let idCounter = 0;
            let rawItems = [];

            if (levelData.type === 'shape') {
                rawItems = levelData.customSticks.map(s => ({...s, type: 'stick'}));
                // Auto generate matching slots for initial sticks
                rawItems = [...rawItems, ...rawItems.map(s => ({...s, type: 'slot'}))];
                // Add valid slots
                if(levelData.winSlots) rawItems = [...rawItems, ...levelData.winSlots.map(s => ({...s, type: 'slot'}))];
                if(levelData.validSlots) rawItems = [...rawItems, ...levelData.validSlots.map(s => ({...s, type: 'slot'}))];
            } else {
                levelData.layout.forEach((part, partIndex) => {
                    let baseX = part.x; 
                    let baseY = 0; 
                    if (part.type === 'digit') {
                        SEGMENT_POSITIONS.forEach((pos, segIndex) => {
                            rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'slot', partIndex, segmentIndex: segIndex });
                            if (DIGIT_MAP[part.value].includes(segIndex)) {
                                rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'stick' });
                            }
                        });
                    } else if (part.type === 'op') {
                        const ops = part.value === '=' ? OP_EQUAL : (part.value === '-' ? OP_MINUS : OP_PLUS);
                        ops.forEach((pos, segIndex) => {
                            if (part.value !== '=') {
                                OP_PLUS.forEach((p, idx) => {
                                    rawItems.push({ x: baseX + p[0], y: baseY + p[1], r: p[2], type: 'slot', partIndex, opType: idx===0?'vert':'horiz' });
                                });
                            } else {
                                rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'slot', partIndex });
                            }
                            if (part.value === '+' || part.value === '=' || (part.value === '-' && segIndex === 0)) {
                                rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'stick' });
                            }
                        });
                    }
                });
            }

            const bounds = calculateBounds(rawItems);
            const contentW = bounds.maxX - bounds.minX;
            const contentH = bounds.maxY - bounds.minY;
            const containerW = 800;
            const containerH = 320;
            const shiftX = Math.round((containerW - contentW) / 2 - bounds.minX);
            const shiftY = Math.round((containerH - contentH) / 2 - bounds.minY);

            // Create Unique Slots map
            const slotMap = new Map();
            const addSlot = (item) => {
                const sx = Math.round(item.x + shiftX);
                const sy = Math.round(item.y + shiftY);
                const key = `${sx},${sy},${item.r}`;
                if(!slotMap.has(key)) {
                    const id = `slot_${idCounter++}`;
                    const s = { id, x: sx, y: sy, r: item.r, partIndex: item.partIndex, opType: item.opType, segmentIndex: item.segmentIndex };
                    slotMap.set(key, s);
                    slots.push(s);
                }
                return slotMap.get(key).id;
            };

            rawItems.forEach(item => {
                if (item.type === 'slot') addSlot(item);
            });

            // Create Sticks
            rawItems.forEach(item => {
                if (item.type === 'stick') {
                    const sx = Math.round(item.x + shiftX);
                    const sy = Math.round(item.y + shiftY);
                    // Ensure a slot exists for every stick (visual consistency)
                    const slotId = addSlot(item);
                    sticks.push({
                        id: `stick_${idCounter++}`,
                        slotId: slotId,
                        x: sx, y: sy, rotation: item.r,
                        color: 'bg-orange-600'
                    });
                }
            });

            return { sticks, slots, shiftX, shiftY };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown }) => (
            <div onMouseDown={onMouseDown} onTouchStart={onMouseDown}
                style={{
                    position: 'absolute', left: x, top: y, width: '80px', height: '10px',
                    backgroundColor: isDragging ? '#fbbf24' : '#d97706', borderRadius: '5px',
                    transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', cursor: 'pointer',
                    zIndex: isDragging ? 50 : 10, touchAction: 'none'
                }}
                className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
            >
                <div style={{ width: '12px', height: '14px', backgroundColor: '#ef4444', borderRadius: '50%', position: 'absolute', left: '-2px', top: '-2px' }}></div>
                <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
            </div>
        );

        const Slot = ({ x, y, rotation, isShape }) => (
            <div className={isShape ? "slot-dash" : "bg-black/5"}
                style={{
                    position: 'absolute', left: x, top: y, width: '80px', height: '10px',
                    borderRadius: '5px', transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', zIndex: 1
                }}
            ></div>
        );

        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing');
            const [hintLevel, setHintLevel] = useState(0);
            const [boardScale, setBoardScale] = useState(1);
            const [levels, setLevels] = useState([]);
            const [offsets, setOffsets] = useState({x:0, y:0});

            const boardRef = useRef(null);
            const gameAreaRef = useRef(null);

            useEffect(() => {
                setLevels(generateLevelSet());
            }, []);

            const currentLevel = levels.length > 0 ? levels[currentLevelIdx] : null;

            useEffect(() => {
                if (currentLevel) loadLevelData(currentLevel);
            }, [currentLevel]);

            useEffect(() => {
                const handleResize = () => {
                    const w = window.innerWidth;
                    setBoardScale(Math.min(1, (w - 32) / 800));
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const loadLevelData = (levelData) => {
                const { sticks: initSticks, slots: initSlots, shiftX, shiftY } = generateSticks(levelData);
                setSticks(initSticks);
                setSlots(initSlots);
                setOffsets({x: shiftX, y: shiftY});
                setMovesCount(0);
                setGameState('playing');
                setHintLevel(0);
            };

            const handleMove = (e) => {
                if (!draggingId || !boardRef.current) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = boardRef.current.getBoundingClientRect();
                const scale = rect.width / 800;
                setMousePos({ x: (clientX - rect.left) / scale - dragOffset.x, y: (clientY - rect.top) / scale - dragOffset.y });
            };
            const handleUp = () => {
                if (draggingId) { snapStick(draggingId, mousePos.x, mousePos.y); setDraggingId(null); }
            };
            useEffect(() => {
                window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false }); window.addEventListener('touchend', handleUp);
                return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); window.removeEventListener('touchmove', handleMove); window.removeEventListener('touchend', handleUp); };
            }, [draggingId, mousePos, dragOffset]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (boardRef.current) {
                    const rect = boardRef.current.getBoundingClientRect();
                    const scale = rect.width / 800;
                    setDragOffset({ x: (clientX - rect.left) / scale - stickX, y: (clientY - rect.top) / scale - stickY });
                    setMousePos({ x: stickX, y: stickY });
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                let nearest = null, minDist = 50;
                const currentStick = sticks.find(s => s.id === stickId);
                slots.forEach(slot => {
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    if (dist < minDist && !isOccupied) { minDist = dist; nearest = slot; }
                });

                if (nearest) {
                    const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id, rotation: nearest.r } : s);
                    if(currentStick.slotId !== nearest.id) setMovesCount(p => p + 1);
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) setSticks(sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s));
                }
            };

            const checkWinCondition = (currentSticks) => {
                if (!currentLevel) return;

                if (currentLevel.type === 'shape') {
                    // Check if win slots are occupied
                    let matchCount = 0;
                    if(!currentLevel.winSlots) return; 
                    
                    const winSlotPivots = currentLevel.winSlots.map(ws => centerToPivot(ws.cx, ws.cy, ws.r));
                    
                    winSlotPivots.forEach(ws => {
                        const targetX = ws.x + offsets.x;
                        const targetY = ws.y + offsets.y;
                        
                        const hasStick = currentSticks.some(s => 
                            Math.abs(s.x - targetX) < 15 && 
                            Math.abs(s.y - targetY) < 15 &&
                            Math.abs(s.rotation - ws.r) < 10
                        );
                        if (hasStick) matchCount++;
                    });

                    // Flexible win: if match count is sufficient
                    if (matchCount >= winSlotPivots.length) {
                        setGameState('won');
                        new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                    }

                } else {
                    // Math Logic
                    const filledSlots = {};
                    currentSticks.forEach(s => {
                        const slot = slots.find(sl => sl.id === s.slotId);
                        if (slot) {
                            if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                            if (slot.opType === 'vert') filledSlots[slot.partIndex].push('vert');
                            else if (slot.opType === 'horiz') filledSlots[slot.partIndex].push('horiz');
                            else filledSlots[slot.partIndex].push(slot.segmentIndex);
                        }
                    });

                    const decodedValues = [], decodedOps = [];
                    let isMalformed = false;

                    currentLevel.layout.forEach((part, idx) => {
                        const segments = filledSlots[idx] || [];
                        if (part.type === 'digit') {
                            let digit = -1;
                            Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                                const a = [...val].sort(), b = [...segments].sort();
                                if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                            });
                            if (digit !== -1) decodedValues.push(digit); else isMalformed = true;
                        } else if (part.type === 'op') {
                            if (part.value === '=') { if (segments.length !== 2) isMalformed = true; }
                            else {
                                const hasVert = segments.includes('vert'), hasHoriz = segments.includes('horiz');
                                if (hasVert && hasHoriz) decodedOps.push('+');
                                else if (!hasVert && hasHoriz) decodedOps.push('-');
                                else isMalformed = true;
                            }
                        }
                    });

                    if (!isMalformed) {
                        try {
                            if (currentLevel.check(decodedValues, decodedOps)) {
                                setGameState('won');
                                new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                            }
                        } catch (e) {}
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < levels.length - 1) setCurrentLevelIdx(p => p + 1);
                else {
                    alert("æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰é—œå¡ï¼30é€±å¹´å¿«æ¨‚ï¼");
                    setLevels(generateLevelSet());
                    setCurrentLevelIdx(0);
                }
            };

            const resetLevel = () => { if(currentLevel) loadLevelData(currentLevel); };

            if (!currentLevel) return <div className="flex h-screen items-center justify-center text-2xl text-orange-600 font-bold">è¼‰å…¥ä¸­...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 w-full max-w-4xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-4 bg-white/80 backdrop-blur p-4 rounded-xl shadow-lg border-b-4 border-orange-300">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-700 tracking-wider">ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</h1>
                            <div className="flex items-center gap-2 mt-2">
                                <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">é—œå¡ {currentLevelIdx + 1}/{levels.length}</span>
                                {currentLevel.id.startsWith('sp') && <span className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm animate-pulse">30é€±å¹´ç‰¹åˆ¥é¡Œ</span>}
                                {currentLevel.type === 'shape' && <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">åœ–å½¢æŒ‘æˆ°</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-xs font-bold uppercase tracking-widest">ç§»å‹•æ¬¡æ•¸</div>
                            <div className="text-3xl font-black text-gray-700">{movesCount}</div>
                        </div>
                    </div>

                    <div className={`border-l-8 p-6 mb-6 w-full rounded-lg shadow-md ${currentLevel.type === 'shape' ? 'bg-blue-50 border-blue-400 text-blue-900' : 'bg-[#fcf8e3] border-yellow-400 text-yellow-800'}`}>
                        <div className="text-lg font-bold mb-1">{currentLevel.title}</div>
                        <div className="text-xl mb-2">{currentLevel.instruction}</div>
                        <div className="text-2xl font-mono bg-white/50 inline-block px-4 py-2 rounded border shadow-inner tracking-widest opacity-80">
                            {currentLevel.formula}
                        </div>
                    </div>

                    <div ref={gameAreaRef} className="relative bg-[#eeeadd] rounded-xl shadow-inner border-4 border-[#d1cbb8] w-full overflow-hidden" style={{ height: '320px', touchAction: 'none' }}>
                        <div className="absolute inset-0 paper-texture"></div>
                        <div ref={boardRef} className="absolute top-[50px] left-1/2 w-[800px] h-[200px] origin-top" style={{ transform: `translateX(-50%) scale(${boardScale})` }}>
                            {slots.map(slot => ( <Slot key={slot.id} x={slot.x} y={slot.y} rotation={slot.r} isShape={currentLevel.type === 'shape'} /> ))}
                            {sticks.map(stick => ( <Stick key={stick.id} x={draggingId === stick.id ? mousePos.x : stick.x} y={draggingId === stick.id ? mousePos.y : stick.y} rotation={stick.rotation} isDragging={draggingId === stick.id} onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)} /> ))}
                        </div>
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-b-8 border-green-500 transform scale-110">
                                    <div className="text-7xl mb-4 float-anim">ğŸ‰</div>
                                    <h2 className="text-4xl font-black text-green-600 mb-2 tracking-tight">ç­”æ¡ˆæ­£ç¢ºï¼</h2>
                                    <button onClick={nextLevel} className="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 flex items-center gap-3 mx-auto">ä¸‹ä¸€é—œ âœ</button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow-lg border border-gray-100">
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2"><span className="text-xl">ğŸ’¡</span> æç¤º</h3>
                                <div className="flex gap-2">
                                    <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 1 ? 'bg-gray-100 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}>LV 1</button>
                                    <button onClick={() => setHintLevel(2)} disabled={hintLevel >= 2 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 2 ? 'bg-gray-100 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}>LV 2</button>
                                </div>
                            </div>
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-4 rounded-lg border border-gray-100 leading-relaxed">
                                {hintLevel === 0 && "å¦‚æœåœ¨è§£é¡Œæ™‚é‡åˆ°å›°é›£ï¼Œå¯ä»¥æŒ‰ä¸Šæ–¹æŒ‰éˆ•ç²å¾—æç¤ºã€‚"}
                                {hintLevel >= 1 && (<div className="animate-pulse text-blue-700 font-medium mb-2 flex items-start gap-2"><span>ğŸ”¹</span> {currentLevel.hint1}</div>)}
                                {hintLevel >= 2 && (<div className="text-purple-700 font-bold flex items-start gap-2"><span>ğŸ”¸</span> {currentLevel.hint2}</div>)}
                            </div>
                        </div>
                        <div className="flex flex-col gap-3">
                            <button onClick={resetLevel} className="flex-1 bg-white hover:bg-gray-50 text-gray-700 font-bold py-3 rounded-xl border-b-4 border-gray-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">ğŸ”„ é‡ç½®æœ¬é—œ</button>
                            <button onClick={nextLevel} className="flex-1 bg-red-50 hover:bg-red-100 text-red-600 font-bold py-3 rounded-xl border-b-4 border-red-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">â© è·³éæœ¬é—œ</button>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
