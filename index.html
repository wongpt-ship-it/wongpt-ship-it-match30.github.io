<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ã€ŒæŸ´ã€é«˜ä¸‰åæ–—</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #d8d4c7; /* Softer, slightly vintage background */
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden; /* Prevent body scroll */
        }
        
        .stick-shadow {
            /* Standard shadow for top-left positioning */
            filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.2));
        }
        
        /* Dashed slot styling */
        .slot-dash {
            border: 2px dashed rgba(0,0,0,0.15);
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }

        /* Paper texture overlay */
        .paper-texture {
            background-image: radial-gradient(#a39e93 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Helpers ---
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        // --- Configuration (CLASSIC ALIGNMENT) ---
        
        const SEG_TOP = [20, 0, 0];
        const SEG_TL  = [10, 20, 90];
        const SEG_TR  = [90, 20, 90];
        const SEG_MID = [20, 80, 0];
        const SEG_BL  = [10, 100, 90];
        const SEG_BR  = [90, 100, 90];
        const SEG_BOT = [20, 160, 0];

        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] 
        };

        const SEGMENT_POSITIONS = [
            SEG_TOP, SEG_TL, SEG_TR, SEG_MID, SEG_BL, SEG_BR, SEG_BOT
        ];

        // Operators
        const OP_PLUS = [[40, 50, 90], [10, 80, 0]];
        const OP_MINUS = [[10, 80, 0]];
        const OP_EQUAL = [[10, 65, 0], [10, 95, 0]];

        // --- COORDINATE CONVERTER ---
        const centerToPivot = (cx, cy, r) => {
            const rad = r * Math.PI / 180;
            return {
                x: cx - 35 * Math.cos(rad),
                y: cy - 35 * Math.sin(rad),
                r: r
            };
        };

        const SL = 80;
        const DIAG = 56;

        // --- POOLS ---

        // 1. Math Pool
        const POOL_MATH = [
            {
                id: 'm1', type: 'math', title: "ç†±èº«é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 5 = 8",
                hint1: "8 ä¸éœ€è¦è®Šå‹•ï¼Œè©¦è‘—æ”¹è®Šå…¶ä¸­ä¸€å€‹ 5ã€‚", hint2: "æŠŠç¬¬ä¸€å€‹ 5 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 3ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => values[0]+values[1]===values[2]
            },
            {
                id: 'm2', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 + 3 = 6",
                hint1: "å˜—è©¦æŠŠ 9 è®Šå°ã€‚", hint2: "æŠŠ 9 è®Šæˆ 5ï¼Œè®Šæˆ 5+3=8ã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 3, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 6, x: 460 }],
                check: (values, ops) => values[0]+values[1]===values[2]
            },
            {
                id: 'm3', type: 'math', title: "ç¶“å…¸é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "6 + 4 = 4",
                hint1: "è©¦è©¦æŠŠåŠ è™Ÿè®Šæ¸›è™Ÿï¼Ÿ", hint2: "8 - 4 = 4 æˆ– 0 + 4 = 4ã€‚",
                layout: [{ type: 'digit', value: 6, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 4, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 4, x: 460 }],
                check: (values, ops) => (ops[0]==='+' && values[0]+values[1]===values[2]) || (ops[0]==='-' && values[0]-values[1]===values[2])
            },
            {
                id: 'm4', type: 'math', title: "æ•¸å­—è®Šèº«", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 9 = 9", 
                hint1: "5 è®Šæˆ 0ã€‚", hint2: "æŠŠ 5 çš„ä¸­é–“ç«æŸ´ç§»åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 9, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 9, x: 460 }],
                check: (values, ops) => values[0]+values[1]===values[2]
            },
            {
                id: 'm5', type: 'math', title: "æ¸›æ³•æŒ‘æˆ°", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 - 5 = 8", 
                hint1: "æ¸›æ³•è®ŠåŠ æ³•ï¼Ÿ", hint2: "3 + 5 = 8ã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '-', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => (ops[0]==='+' && values[0]+values[1]===values[2])
            },
            {
                id: 'm6', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "3 + 6 = 3",
                hint1: "è©¦è©¦çœ‹ 9 - 6 = 3ã€‚", hint2: "æŠŠåŠ è™Ÿè®Šæˆæ¸›è™Ÿã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 6, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 3, x: 460 }],
                check: (values, ops) => (ops[0]==='-' && values[0]-values[1]===values[2])
            },
            {
                id: 'm7', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 7 = 2",
                hint1: "9 - 7 = 2ã€‚", hint2: "æŠŠåŠ è™Ÿçš„ç›´ç«æŸ´ç§»åˆ° 5 ä¸Šã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 7, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 2, x: 460 }],
                check: (values, ops) => (ops[0]==='-' && values[0]-values[1]===values[2])
            }
        ];

        // 2. Shape Pool
        const POOL_SHAPE = [
            {
                id: 's4', type: 'shape', title: "äº•å­—è®Šæ­£æ–¹å½¢", instruction: "ç§»å‹• 3 æ ¹ç«æŸ´ï¼Œå½¢æˆ 3 å€‹æ­£æ–¹å½¢", formula: "åœ–å½¢é¡Œ",
                hint1: "è©¦è‘—æŠŠå¤–åœçš„ç«æŸ´ç§»åˆ°å…§éƒ¨ã€‚", hint2: "åˆ©ç”¨ä¸­é–“çš„ç©ºé–“ï¼Œå½¢æˆä¸‰å€‹ç›¸é€£çš„æ­£æ–¹å½¢ï¼ˆä»¥ã€Œå“ã€å­—å½¢æˆ–Lå½¢æ’åˆ—ï¼‰ã€‚",
                // Well Shape: Center Box + 8 extensions.
                customSticks: [
                    // Center Square
                    {cx:400, cy:120, r:0}, {cx:400, cy:200, r:0}, // Horiz
                    {cx:360, cy:160, r:90}, {cx:440, cy:160, r:90}, // Vert
                    // Extensions
                    {cx:320, cy:120, r:0}, {cx:480, cy:120, r:0}, // Top Exts
                    {cx:320, cy:200, r:0}, {cx:480, cy:200, r:0}, // Bot Exts
                    {cx:360, cy:80, r:90}, {cx:360, cy:240, r:90}, // Left Exts
                    {cx:440, cy:80, r:90}, {cx:440, cy:240, r:90}  // Right Exts
                ].map(s => centerToPivot(s.cx, s.cy, s.r)),
                // Valid Slots: Full 40px Grid for brick-laying
                validSlots: (() => {
                    const slots = [];
                    // Generate full grid (Horiz and Vert slots at every 40px intersection)
                    for(let x=240; x<=560; x+=40) {
                        for(let y=40; y<=280; y+=40) {
                            slots.push({cx:x, cy:y, r:0});
                            slots.push({cx:x, cy:y, r:90});
                        }
                    }
                    return slots.map(s => centerToPivot(s.cx, s.cy, s.r));
                })(),
                checkGeometry: '3_squares' // Flag for ANY 3 squares
            },
            {
                id: 's5', type: 'shape', title: "æ–¹ä¸­ä¹‹æ–¹", instruction: "ç§»å‹• 4 æ ¹ç«æŸ´ï¼Œå½¢æˆ 3 å€‹æ­£æ–¹å½¢", formula: "åœ–å½¢é¡Œ",
                hint1: "ç¾åœ¨æ˜¯ä¸€å€‹å¤§æ­£æ–¹å½¢åŒ…è‘—ä¸€å€‹å°æ­£æ–¹å½¢ã€‚", hint2: "æŠŠå¤§æ­£æ–¹å½¢çš„é‚Šæ‹†ä¸‹ä¾†ï¼Œèˆ‡è£¡é¢çš„æ­£æ–¹å½¢çµ„åˆæˆä¸‰å€‹ç¨ç«‹çš„æ­£æ–¹å½¢ã€‚",
                // Layout: Outer Square (2x2) containing Inner Square (1x1)
                // Center 400, 160.
                customSticks: [
                    // Inner Square (1x1)
                    {cx:400, cy:120, r:0}, {cx:400, cy:200, r:0}, // Horiz
                    {cx:360, cy:160, r:90}, {cx:440, cy:160, r:90}, // Vert
                    // Outer Square (2x2, gap 40px from inner)
                    // Top Row (y=80)
                    {cx:360, cy:80, r:0}, {cx:440, cy:80, r:0},
                    // Bot Row (y=240)
                    {cx:360, cy:240, r:0}, {cx:440, cy:240, r:0},
                    // Left Col (x=320)
                    {cx:320, cy:120, r:90}, {cx:320, cy:200, r:90},
                    // Right Col (x=480)
                    {cx:480, cy:120, r:90}, {cx:480, cy:200, r:90}
                ].map(s => centerToPivot(s.cx, s.cy, s.r)),
                // Valid Slots: Full 40px Grid
                validSlots: (() => {
                    const slots = [];
                    for(let x=240; x<=560; x+=40) {
                        for(let y=40; y<=280; y+=40) {
                            slots.push({cx:x, cy:y, r:0});
                            slots.push({cx:x, cy:y, r:90});
                        }
                    }
                    return slots.map(s => centerToPivot(s.cx, s.cy, s.r));
                })(),
                checkGeometry: '3_squares'
            }
        ];

        const POOL_SPECIAL = [
            { id: 'sp1', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸€)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "26 + 4 = 20", layout: [{ type: 'digit', value: 2, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 4, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 2, x: 510 }, { type: 'digit', value: 0, x: 610 }], check: (values, ops) => (values[0]*10+values[1])+values[2]===30 },
            { id: 'sp2', type: 'math', title: "ä¸‰åè€Œç«‹ (äºŒ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "36 - 6 = 36", layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 6, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }], check: (values, ops) => (values[0]*10+values[1])-values[2]===30 },
            { id: 'sp3', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸‰)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "35 - 5 = 39", layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 5, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 9, x: 610 }], check: (values, ops) => (values[0]*10+values[1])-values[2]===30 },
            { id: 'sp4', type: 'math', title: "ä¸‰åè€Œç«‹ (å››)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "39 - 9 = 36", layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 9, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 9, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }], check: (values, ops) => (values[0]*10+values[1])-values[2]===30 },
            { id: 'sp5', type: 'math', title: "ä¸‰åé€±å¹´ (çµ‚æ¥µ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "15 + 15 = 50", layout: [{ type: 'digit', value: 1, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 1, x: 310 }, { type: 'digit', value: 5, x: 410 }, { type: 'op', value: '=', x: 530 }, { type: 'digit', value: 5, x: 610 }, { type: 'digit', value: 0, x: 710 }], check: (values, ops) => (values[0]*10+values[1])+(values[2]*10+values[3])===30 }
        ];

        const generateLevelSet = () => {
            const math = shuffleArray(POOL_MATH).slice(0, 2);
            // Select 1 shape level (from 2 available)
            const shape = shuffleArray(POOL_SHAPE).slice(0, 1);
            const special = shuffleArray(POOL_SPECIAL).slice(0, 2);
            return [...math, ...shape, ...special];
        };

        // --- GEOMETRY CHECKER (Generic 3 Squares) ---
        const getFoundSquares = (sticks) => {
            const tolerance = 15;
            const hSticks = [], vSticks = [];
            
            sticks.forEach(s => {
                const rot = (s.rotation % 180 + 180) % 180; 
                if (Math.abs(rot) < 10) hSticks.push({x: s.x, y: s.y});
                else if (Math.abs(rot - 90) < 10) vSticks.push({x: s.x, y: s.y});
            });

            const squares = [];
            
            hSticks.forEach(top => {
                // Find Bottom H (y + 80)
                const bot = hSticks.find(b => Math.abs(b.x - top.x) < tolerance && Math.abs(b.y - (top.y + 80)) < tolerance);
                if (bot) {
                    // Find Left V (x-5, y+5)
                    const left = vSticks.find(l => Math.abs(l.x - (top.x - 5)) < tolerance && Math.abs(l.y - (top.y + 5)) < tolerance);
                    // Find Right V (x+75, y+5)
                    const right = vSticks.find(r => Math.abs(r.x - (top.x + 75)) < tolerance && Math.abs(r.y - (top.y + 5)) < tolerance);

                    if (left && right) {
                        squares.push({x: top.x, y: top.y});
                    }
                }
            });
            return squares;
        };

        // --- REMAINDER OF APP (Logic same as before) ---
        
        const calculateBounds = (items) => {
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            items.forEach(item => {
                const rad = item.r * Math.PI / 180;
                const corners = [{x: -5, y: -5}, {x: 75, y: -5}, {x: -5, y: 5}, {x: 75, y: 5}];
                corners.forEach(c => {
                    const rx = c.x * Math.cos(rad) - c.y * Math.sin(rad);
                    const ry = c.x * Math.sin(rad) + c.y * Math.cos(rad);
                    minX = Math.min(minX, item.x + rx);
                    maxX = Math.max(maxX, item.x + rx);
                    minY = Math.min(minY, item.y + ry);
                    maxY = Math.max(maxY, item.y + ry);
                });
            });
            return { minX, maxX, minY, maxY };
        };

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = [];
            let idCounter = 0;
            let rawItems = [];

            if (levelData.type === 'shape') {
                rawItems = levelData.customSticks.map(s => ({...s, type: 'stick'}));
                // Auto slots for sticks
                rawItems = [...rawItems, ...rawItems.map(s => ({...s, type: 'slot'}))];
                // Extra Valid Slots
                if(levelData.validSlots) rawItems = [...rawItems, ...levelData.validSlots.map(s => ({...s, type: 'slot'}))];
            } else {
                // Math Gen Logic
                levelData.layout.forEach((part, partIndex) => {
                    let baseX = part.x; let baseY = 0; 
                    if (part.type === 'digit') {
                        SEGMENT_POSITIONS.forEach((pos, segIndex) => {
                            rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'slot', partIndex, segmentIndex: segIndex });
                            if (DIGIT_MAP[part.value].includes(segIndex)) rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'stick' });
                        });
                    } else if (part.type === 'op') {
                        const ops = part.value === '=' ? OP_EQUAL : (part.value === '-' ? OP_MINUS : OP_PLUS);
                        ops.forEach((pos, segIndex) => {
                            if (part.value !== '=') {
                                OP_PLUS.forEach((p, idx) => rawItems.push({ x: baseX + p[0], y: baseY + p[1], r: p[2], type: 'slot', partIndex, opType: idx===0?'vert':'horiz' }));
                            } else {
                                rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'slot', partIndex });
                            }
                            if (part.value === '+' || part.value === '=' || (part.value === '-' && segIndex === 0)) {
                                rawItems.push({ x: baseX + pos[0], y: baseY + pos[1], r: pos[2], type: 'stick' });
                            }
                        });
                    }
                });
            }

            const bounds = calculateBounds(rawItems);
            // SHIFT UP: Subtract 50 from Y
            const shiftX = Math.round((800 - (bounds.maxX - bounds.minX)) / 2 - bounds.minX);
            const shiftY = Math.round((320 - (bounds.maxY - bounds.minY)) / 2 - bounds.minY) - 50;

            const slotMap = new Map();
            const addSlot = (item) => {
                const sx = Math.round(item.x + shiftX);
                const sy = Math.round(item.y + shiftY);
                const key = `${sx},${sy},${item.r}`;
                if(!slotMap.has(key)) {
                    const id = `slot_${idCounter++}`;
                    const s = { id, x: sx, y: sy, r: item.r, partIndex: item.partIndex, opType: item.opType, segmentIndex: item.segmentIndex };
                    slotMap.set(key, s);
                    slots.push(s);
                }
                return slotMap.get(key).id;
            };

            rawItems.forEach(item => { if (item.type === 'slot') addSlot(item); });
            rawItems.forEach(item => {
                if (item.type === 'stick') {
                    const sx = Math.round(item.x + shiftX);
                    const sy = Math.round(item.y + shiftY);
                    const slotId = addSlot(item);
                    sticks.push({ id: `stick_${idCounter++}`, slotId, x: sx, y: sy, rotation: item.r, color: 'bg-orange-600' });
                }
            });

            return { sticks, slots, shiftX, shiftY };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown }) => (
            <div onMouseDown={onMouseDown} onTouchStart={onMouseDown}
                style={{ position: 'absolute', left: x, top: y, width: '80px', height: '10px', backgroundColor: isDragging ? '#fbbf24' : '#d97706', borderRadius: '5px', transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', cursor: 'pointer', zIndex: isDragging ? 50 : 10, touchAction: 'none' }}
                className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
            >
                <div style={{ width: '12px', height: '14px', backgroundColor: '#ef4444', borderRadius: '50%', position: 'absolute', left: '-2px', top: '-2px' }}></div>
                <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
            </div>
        );

        const Slot = ({ x, y, rotation }) => (
            <div className="slot-dash" style={{ position: 'absolute', left: x, top: y, width: '80px', height: '10px', borderRadius: '5px', transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', zIndex: 1 }}></div>
        );

        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing');
            const [hintLevel, setHintLevel] = useState(0);
            const [boardScale, setBoardScale] = useState(1);
            const [levels, setLevels] = useState([]);
            const [offsets, setOffsets] = useState({x:0, y:0});
            const boardRef = useRef(null);
            const gameAreaRef = useRef(null);

            useEffect(() => { setLevels(generateLevelSet()); }, []);
            const currentLevel = levels.length > 0 ? levels[currentLevelIdx] : null;
            useEffect(() => { if (currentLevel) loadLevelData(currentLevel); }, [currentLevel]);
            useEffect(() => {
                const handleResize = () => setBoardScale(Math.min(1, (window.innerWidth - 32) / 800));
                handleResize(); window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const loadLevelData = (levelData) => {
                const { sticks: s, slots: sl, shiftX, shiftY } = generateSticks(levelData);
                setSticks(s); setSlots(sl); setOffsets({x: shiftX, y: shiftY});
                setMovesCount(0); setGameState('playing'); setHintLevel(0);
            };

            const handleMove = (e) => {
                if (!draggingId || !boardRef.current) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = boardRef.current.getBoundingClientRect();
                const scale = rect.width / 800;
                setMousePos({ x: (clientX - rect.left) / scale - dragOffset.x, y: (clientY - rect.top) / scale - dragOffset.y });
            };
            const handleUp = () => { if (draggingId) { snapStick(draggingId, mousePos.x, mousePos.y); setDraggingId(null); } };
            
            useEffect(() => {
                window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false }); window.addEventListener('touchend', handleUp);
                return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); window.removeEventListener('touchmove', handleMove); window.removeEventListener('touchend', handleUp); };
            }, [draggingId, mousePos, dragOffset]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (boardRef.current) {
                    const rect = boardRef.current.getBoundingClientRect();
                    const scale = rect.width / 800;
                    setDragOffset({ x: (clientX - rect.left) / scale - stickX, y: (clientY - rect.top) / scale - stickY });
                    setMousePos({ x: stickX, y: stickY });
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                let nearest = null, minDist = 50;
                const currentStick = sticks.find(s => s.id === stickId);
                slots.forEach(slot => {
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    if (dist < minDist && !isOccupied) { minDist = dist; nearest = slot; }
                });
                if (nearest) {
                    const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id, rotation: nearest.r } : s);
                    if(currentStick.slotId !== nearest.id) setMovesCount(p => p + 1);
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) setSticks(sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s));
                }
            };

            const checkWinCondition = (currentSticks) => {
                if (!currentLevel) return;

                if (currentLevel.checkGeometry === '3_squares' || currentLevel.checkGeometry === '2_squares') {
                    const target = currentLevel.checkGeometry === '3_squares' ? 3 : 2;
                    const sq = getFoundSquares(currentSticks);
                    // Check if unique squares (by simplified center or top-left)
                    const unique = new Set(sq.map(s => `${Math.round(s.x)},${Math.round(s.y)}`));
                    if (unique.size >= target) {
                        setGameState('won');
                        new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                    }
                } else if (currentLevel.type === 'shape') {
                     // ...
                } else {
                    // Math Logic (Existing)
                    const filledSlots = {};
                    currentSticks.forEach(s => {
                        const slot = slots.find(sl => sl.id === s.slotId);
                        if (slot) {
                            if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                            if (slot.opType === 'vert') filledSlots[slot.partIndex].push('vert');
                            else if (slot.opType === 'horiz') filledSlots[slot.partIndex].push('horiz');
                            else filledSlots[slot.partIndex].push(slot.segmentIndex);
                        }
                    });
                    const decodedValues = [], decodedOps = [];
                    let isMalformed = false;
                    currentLevel.layout.forEach((part, idx) => {
                        const segments = filledSlots[idx] || [];
                        if (part.type === 'digit') {
                            let digit = -1;
                            Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                                const a = [...val].sort(), b = [...segments].sort();
                                if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                            });
                            if (digit !== -1) decodedValues.push(digit); else isMalformed = true;
                        } else if (part.type === 'op') {
                            if (part.value === '=') { if (segments.length !== 2) isMalformed = true; }
                            else {
                                const hasVert = segments.includes('vert'), hasHoriz = segments.includes('horiz');
                                if (hasVert && hasHoriz) decodedOps.push('+');
                                else if (!hasVert && hasHoriz) decodedOps.push('-');
                                else isMalformed = true;
                            }
                        }
                    });
                    if (!isMalformed) {
                        try {
                            if (currentLevel.check(decodedValues, decodedOps)) {
                                setGameState('won');
                                new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                            }
                        } catch (e) {}
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < levels.length - 1) setCurrentLevelIdx(p => p + 1);
                else {
                    alert("æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰é—œå¡ï¼30é€±å¹´å¿«æ¨‚ï¼");
                    setLevels(generateLevelSet()); setCurrentLevelIdx(0);
                }
            };
            const resetLevel = () => { if(currentLevel) loadLevelData(currentLevel); };

            if (!currentLevel) return <div className="flex h-screen items-center justify-center text-2xl text-orange-600 font-bold">è¼‰å…¥ä¸­...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 w-full max-w-4xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-4 bg-white/80 backdrop-blur p-4 rounded-xl shadow-lg border-b-4 border-orange-300">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-700 tracking-wider">ã€ŒæŸ´ã€é«˜ä¸‰åæ–—</h1>
                            <div className="flex items-center gap-2 mt-2">
                                <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">é—œå¡ {currentLevelIdx + 1}/{levels.length}</span>
                                {currentLevel.id.startsWith('sp') && <span className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm animate-pulse">30é€±å¹´ç‰¹åˆ¥é¡Œ</span>}
                                {currentLevel.type === 'shape' && <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">åœ–å½¢æŒ‘æˆ°</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-xs font-bold uppercase tracking-widest">ç§»å‹•æ¬¡æ•¸</div>
                            <div className="text-3xl font-black text-gray-700">{movesCount}</div>
                        </div>
                    </div>
                    <div className={`border-l-8 p-6 mb-6 w-full rounded-lg shadow-md ${currentLevel.type === 'shape' ? 'bg-blue-50 border-blue-400 text-blue-900' : 'bg-[#fcf8e3] border-yellow-400 text-yellow-800'}`}>
                        <div className="text-lg font-bold mb-1">{currentLevel.title}</div>
                        <div className="text-xl mb-2">{currentLevel.instruction}</div>
                        <div className="text-2xl font-mono bg-white/50 inline-block px-4 py-2 rounded border shadow-inner tracking-widest opacity-80">{currentLevel.formula}</div>
                    </div>
                    <div ref={gameAreaRef} className="relative bg-[#eeeadd] rounded-xl shadow-inner border-4 border-[#d1cbb8] w-full overflow-hidden" style={{ height: '320px', touchAction: 'none' }}>
                        <div className="absolute inset-0 paper-texture"></div>
                        <div ref={boardRef} className="absolute top-[50px] left-1/2 w-[800px] h-[200px] origin-top" style={{ transform: `translateX(-50%) scale(${boardScale})` }}>
                            {slots.map(slot => ( <Slot key={slot.id} x={slot.x} y={slot.y} rotation={slot.r} /> ))}
                            {sticks.map(stick => ( <Stick key={stick.id} x={draggingId === stick.id ? mousePos.x : stick.x} y={draggingId === stick.id ? mousePos.y : stick.y} rotation={stick.rotation} isDragging={draggingId === stick.id} onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)} /> ))}
                        </div>
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-b-8 border-green-500 transform scale-110">
                                    <div className="text-7xl mb-4 float-anim">ğŸ‰</div>
                                    <h2 className="text-4xl font-black text-green-600 mb-2 tracking-tight">ç­”æ¡ˆæ­£ç¢ºï¼</h2>
                                    <button onClick={nextLevel} className="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 flex items-center gap-3 mx-auto">ä¸‹ä¸€é—œ âœ</button>
                                </div>
                            </div>
                        )}
                    </div>
                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow-lg border border-gray-100">
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2"><span className="text-xl">ğŸ’¡</span> æç¤º</h3>
                                <div className="flex gap-2">
                                    <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 1 ? 'bg-gray-100 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}>LV 1</button>
                                    <button onClick={() => setHintLevel(2)} disabled={hintLevel >= 2 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 2 ? 'bg-gray-100 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}>LV 2</button>
                                </div>
                            </div>
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-4 rounded-lg border border-gray-100 leading-relaxed">
                                {hintLevel === 0 && "å¦‚æœåœ¨è§£é¡Œæ™‚é‡åˆ°å›°é›£ï¼Œå¯ä»¥æŒ‰ä¸Šæ–¹æŒ‰éˆ•ç²å¾—æç¤ºã€‚"}
                                {hintLevel >= 1 && (<div className="animate-pulse text-blue-700 font-medium mb-2 flex items-start gap-2"><span>ğŸ”¹</span> {currentLevel.hint1}</div>)}
                                {hintLevel >= 2 && (<div className="text-purple-700 font-bold flex items-start gap-2"><span>ğŸ”¸</span> {currentLevel.hint2}</div>)}
                            </div>
                        </div>
                        <div className="flex flex-col gap-3">
                            <button onClick={resetLevel} className="flex-1 bg-white hover:bg-gray-50 text-gray-700 font-bold py-3 rounded-xl border-b-4 border-gray-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">ğŸ”„ é‡ç½®æœ¬é—œ</button>
                            <button onClick={nextLevel} className="flex-1 bg-red-50 hover:bg-red-100 text-red-600 font-bold py-3 rounded-xl border-b-4 border-red-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">â© è·³éæœ¬é—œ</button>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
