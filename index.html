<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #d8d4c7;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden; /* Prevent body scroll */
        }
        
        .stick-shadow {
            filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.2));
        }
        
        .slot-dash {
            border: 2px dashed rgba(0,0,0,0.15);
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }

        /* Paper texture overlay */
        .paper-texture {
            background-image: radial-gradient(#a39e93 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Helpers ---
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        // --- Configuration ---

        // 7-segment positions (Relative to a 100x180 digit box)
        const SEG_TOP = [20, 0, 0];
        const SEG_TL  = [10, 20, 90];
        const SEG_TR  = [90, 20, 90];
        const SEG_MID = [20, 80, 0];
        const SEG_BL  = [10, 100, 90];
        const SEG_BR  = [90, 100, 90];
        const SEG_BOT = [20, 160, 0];

        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] 
        };

        const SEGMENT_POSITIONS = [
            SEG_TOP, SEG_TL, SEG_TR, SEG_MID, SEG_BL, SEG_BR, SEG_BOT
        ];

        // Operator Stick Positions
        const OP_PLUS = [[40, 50, 90], [10, 80, 0]];
        const OP_MINUS = [[10, 80, 0]];
        const OP_EQUAL = [[10, 65, 0], [10, 95, 0]];

        // --- VALIDATION HELPER ---
        // Generic checker for A +/- B = C or A +/- B = C +/- D
        const checkMath = (values, ops) => {
            if (values.length === 3 && ops.length === 1) {
                // A op B = C
                const res = ops[0] === '+' ? values[0] + values[1] : values[0] - values[1];
                return res === values[2];
            } 
            if (values.length === 5 && ops.length === 1) {
                // Double digit math (implicit 2 digits per number usually in this game's logic for 30th)
                // Actually the parser flattens digits.
                // e.g. 26 + 4 = 20 -> values [2,6, 4, 2,0]
                // Construct numbers based on context? 
                // The levels have fixed structure. We can try to interpret based on length.
                // But for 30th anniversary, it's mostly Double +/- Single = Double.
                // Let's rely on specific level checks for complex ones, but generic for simple ones.
                return false;
            }
            return false;
        };

        // --- POOLS ---

        // 1. Math Pool
        const POOL_MATH = [
            {
                id: 'm1', type: 'math', title: "ç†±èº«é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 5 = 8",
                hint1: "8 ä¸éœ€è¦è®Šå‹•ï¼Œè©¦è‘—æ”¹è®Šå…¶ä¸­ä¸€å€‹ 5ã€‚", hint2: "æŠŠç¬¬ä¸€å€‹ 5 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 3ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm2', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 + 3 = 6",
                hint1: "å˜—è©¦æŠŠ 9 è®Šå°ã€‚", hint2: "æŠŠ 9 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ° 6 çš„ç¼ºå£ï¼Œè®“å®ƒè®Šæˆ 8ã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 3, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 6, x: 460 }],
                // Target: 5 + 3 = 8
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm3', type: 'math', title: "ç¶“å…¸é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "6 + 4 = 4",
                hint1: "é€™é¡Œæœ‰å¤šå€‹è§£æ³•ï¼è©¦è©¦æŠŠåŠ è™Ÿè®Šæ¸›è™Ÿï¼Ÿ", hint2: "è§£æ³•ä¸€ï¼š8 - 4 = 4ã€‚è§£æ³•äºŒï¼š0 + 4 = 4ã€‚",
                layout: [{ type: 'digit', value: 6, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 4, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 4, x: 460 }],
                // Supports 0+4=4 AND 8-4=4
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm4', type: 'math', title: "æ•¸å­—è®Šèº«", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 - 5 = 8", 
                // Replaced 9+9=0 with a solid one. Target: 3 + 5 = 8.
                hint1: "æ¸›æ³•è®ŠåŠ æ³•ï¼Ÿ", hint2: "æŠŠ 9 è®Šæˆ 3ï¼Œæ¸›è™Ÿè®ŠåŠ è™Ÿã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '-', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm5', type: 'math', title: "æ¸›æ³•æŒ‘æˆ°", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 7 = 2",
                hint1: "åŠ æ³•è®Šæ¸›æ³•ï¼Ÿ", hint2: "æŠŠåŠ è™Ÿçš„ä¸€æ ¹ç«æŸ´ç§»åˆ° 5 ä¸Šï¼Œè®“å®ƒè®Šæˆ 9ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 7, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 2, x: 460 }],
                check: (values, ops) => checkMath(values, ops) // 9 - 7 = 2
            },
            {
                id: 'm6', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "3 + 6 = 3",
                hint1: "è©¦è©¦çœ‹ 3 åŠ  0ã€‚", hint2: "æŠŠ 6 è®Šæˆ 0ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 6, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 3, x: 460 }],
                // Supports 3+0=3 AND 9-6=3
                check: (values, ops) => checkMath(values, ops)
            }
        ];

        // 2. Shape Pool
        const POOL_SHAPE = [
            {
                id: 's1', type: 'shape', title: "æ¸¸å‹•çš„å°é­š", instruction: "ç§»å‹• 3 æ ¹ç«æŸ´ï¼Œè®“é­šå‘åæ–¹å‘æ¸¸",
                formula: "åœ–å½¢é¡Œ",
                hint1: "é­šé ­ç¾åœ¨å‘å·¦ï¼Œè¦æŠŠå®ƒè®Šå‘å³ã€‚", hint2: "ç§»å‹•é­šé°­å’Œä¸‹åŠéƒ¨çš„èº«é«”ã€‚",
                customSticks: [
                    {x:300, y:80, r:45}, {x:300, y:180, r:135}, 
                    {x:350, y:100, r:0}, {x:350, y:160, r:0}, 
                    {x:320, y:130, r:90}, {x:380, y:130, r:90}, 
                    {x:400, y:100, r:45}, {x:400, y:160, r:135} 
                ],
                winSlots: [
                    {x:350, y:100, r:0}, {x:350, y:160, r:0}, 
                    {x:320, y:130, r:90}, {x:380, y:130, r:90}, 
                    {x:400, y:80, r:135}, {x:400, y:180, r:45}, 
                    {x:300, y:100, r:135}, {x:300, y:160, r:45} 
                ],
                validSlots: [
                    {x:300, y:80, r:45}, {x:300, y:180, r:135}, {x:400, y:80, r:135}, {x:400, y:180, r:45}, 
                    {x:400, y:100, r:45}, {x:400, y:160, r:135}, {x:300, y:100, r:135}, {x:300, y:160, r:45}, 
                    {x:350, y:100, r:0}, {x:350, y:160, r:0}, {x:320, y:130, r:90}, {x:380, y:130, r:90} 
                ]
            },
            {
                id: 's2', type: 'shape', title: "å…©å€‹ç®­é ­", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠå…©å€‹ç®­é ­è®Šæˆä¸€å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "å°‡å…©å€‹ç®­é ­çš„å°¾éƒ¨é€£èµ·ä¾†ã€‚", hint2: "é€™æ˜¯ä¸€å€‹è¦–éŒ¯è¦ºï¼Œä¸éœ€è¦å®Œç¾çš„æ­£æ–¹å½¢ï¼Œé•·æ–¹å½¢(Box)ä¹Ÿå¯ä»¥ã€‚",
                customSticks: [
                    {x:200, y:100, r:45}, {x:200, y:160, r:135}, 
                    {x:250, y:100, r:135}, {x:250, y:160, r:45}, 
                    {x:350, y:100, r:135}, {x:350, y:160, r:45}, 
                ],
                winSlots: [
                   {x:250, y:90, r:0}, {x:250, y:170, r:0}, 
                   {x:210, y:130, r:90}, {x:290, y:130, r:90} 
                ],
                validSlots: [
                    {x:250, y:100, r:135}, {x:250, y:160, r:45}, {x:350, y:100, r:135}, {x:350, y:160, r:45}, 
                    {x:300, y:80, r:0}, {x:300, y:180, r:0}, {x:260, y:130, r:90}, {x:340, y:130, r:90}, 
                    {x:290, y:90, r:0}, {x:290, y:170, r:0}, {x:250, y:130, r:90}, {x:330, y:130, r:90},
                ]
            },
            {
                id: 's3', type: 'shape', title: "ä¸‰å€‹æ­£æ–¹å½¢", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠä¸‰å€‹æ­£æ–¹å½¢è®Šæˆå…©å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "è©¦è‘—æŠŠä¸­é–“çš„æ­£æ–¹å½¢æ‹†æ‰ã€‚", hint2: "æŠŠä¸­é–“æ­£æ–¹å½¢çš„å…©æ ¹ç›´ç«æŸ´æ‹¿èµ°ï¼Œæ”¾åˆ°å“ªè£¡å‘¢ï¼Ÿè£œä¸Šç¼ºå£ã€‚",
                customSticks: [
                    {x:200, y:100, r:0}, {x:280, y:100, r:0}, {x:360, y:100, r:0},
                    {x:200, y:180, r:0}, {x:280, y:180, r:0}, {x:360, y:180, r:0},
                    {x:160, y:140, r:90}, {x:240, y:140, r:90}, {x:320, y:140, r:90}, {x:400, y:140, r:90}
                ],
                winSlots: [
                    {x:200, y:100, r:0}, {x:200, y:180, r:0}, {x:160, y:140, r:90}, {x:240, y:140, r:90},
                    {x:400, y:100, r:0}, {x:400, y:180, r:0}, {x:360, y:140, r:90}, {x:440, y:140, r:90}
                ],
                validSlots: [
                   {x:200, y:100, r:0}, {x:280, y:100, r:0}, {x:360, y:100, r:0},
                   {x:200, y:180, r:0}, {x:280, y:180, r:0}, {x:360, y:180, r:0},
                   {x:160, y:140, r:90}, {x:240, y:140, r:90}, {x:320, y:140, r:90}, {x:400, y:140, r:90},
                   {x:400, y:100, r:0}, {x:400, y:180, r:0}, {x:440, y:140, r:90}, {x:360, y:140, r:90}
                ]
            }
        ];

        // 3. Special Pool (30th)
        const POOL_SPECIAL = [
            {
                id: 'sp1', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸€)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "26 + 4 = 20",
                hint1: "æŠŠç­”æ¡ˆ 20 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 20 çš„å·¦ä¸‹è§’ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 2, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 4, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 2, x: 510 }, { type: 'digit', value: 0, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) + values[2] === 30
            },
            {
                id: 'sp2', type: 'math', title: "ä¸‰åè€Œç«‹ (äºŒ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "36 - 6 = 36",
                hint1: "æŠŠç­”æ¡ˆ 36 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 6, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 'sp3', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸‰)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "35 - 5 = 39",
                hint1: "35 æ¸› 5 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 39 çš„ 9 è®Šæˆ 0ã€‚ç§»å‹• 9 çš„ä¸­é–“ç«æŸ´åˆ°å·¦ä¸‹è§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 5, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 9, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp4', type: 'math', title: "ä¸‰åè€Œç«‹ (å››)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "39 - 9 = 36",
                hint1: "39 æ¸› 9 ç­‰æ–¼ 30ã€‚", hint2: "æŠŠçµæœ 36 çš„ 6 è®Šæˆ 0ã€‚ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 9, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 9, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp5', type: 'math', title: "ä¸‰åé€±å¹´ (çµ‚æ¥µ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "15 + 15 = 50",
                hint1: "15 + 15 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 50 çš„ 5 è®Šæˆ 3ã€‚ç§»å‹•å·¦ä¸Šè§’çš„ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 1, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 1, x: 310 }, { type: 'digit', value: 5, x: 410 }, { type: 'op', value: '=', x: 530 }, { type: 'digit', value: 5, x: 610 }, { type: 'digit', value: 0, x: 710 }],
                check: (values) => values.length === 6 && (values[0]*10 + values[1]) + (values[2]*10 + values[3]) === 30
            }
        ];

        const generateLevelSet = () => {
            const math = shuffleArray(POOL_MATH).slice(0, 4);
            const shape = shuffleArray(POOL_SHAPE).slice(0, 2);
            const special = shuffleArray(POOL_SPECIAL).slice(0, 4);
            return [...math, ...shape, ...special];
        };

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = [];
            let idCounter = 0;
            let minX = Infinity;
            let maxX = -Infinity;

            // 1. Calculate Bounds
            if (levelData.type === 'shape') {
                // For shapes, iterate through validSlots and customSticks to find bounds
                const allItems = [...levelData.customSticks, ...(levelData.validSlots || [])];
                allItems.forEach(item => {
                    if (item.x < minX) minX = item.x;
                    if (item.x + 80 > maxX) maxX = item.x + 80; // stick length approx 80
                });
            } else {
                levelData.layout.forEach(part => {
                    if (part.x < minX) minX = part.x;
                    const width = part.type === 'digit' ? 110 : 80;
                    if (part.x + width > maxX) maxX = part.x + width;
                });
            }

            const contentWidth = maxX - minX;
            const containerWidth = 800;
            const shiftX = (containerWidth - contentWidth) / 2 - minX;

            // 2. Generate
            if (levelData.type === 'shape') {
                const baseY = 50; // Shape offset
                
                // Add Sticks
                levelData.customSticks.forEach(s => {
                    // Create matching slot for initial position
                     slots.push({
                        id: `slot_init_${idCounter}`,
                        x: s.x + shiftX, y: s.y + baseY, r: s.r,
                        type: 'shape'
                    });
                    
                    sticks.push({
                        id: `stick_${idCounter++}`,
                        slotId: `slot_init_${idCounter-1}`, // bind to the slot we just made
                        x: s.x + shiftX, y: s.y + baseY, rotation: s.r,
                        color: 'bg-orange-600'
                    });
                });

                // Add Extra Valid Slots
                if (levelData.validSlots) {
                    levelData.validSlots.forEach((s, idx) => {
                        const exists = slots.some(ex => Math.abs(ex.x - (s.x + shiftX)) < 5 && Math.abs(ex.y - (s.y + baseY)) < 5);
                        if (!exists) {
                            slots.push({
                                id: `slot_extra_${idx}`,
                                x: s.x + shiftX, y: s.y + baseY, r: s.r,
                                type: 'shape'
                            });
                        }
                    });
                }
            } else {
                // Math Logic
                levelData.layout.forEach((part, partIndex) => {
                    let baseX = part.x + shiftX;
                    let baseY = 30;

                    if (part.type === 'digit') {
                        SEGMENT_POSITIONS.forEach((pos, segIndex) => {
                            const slotId = `slot_${partIndex}_${segIndex}`;
                            const isPresent = DIGIT_MAP[part.value].includes(segIndex);
                            slots.push({ id: slotId, x: baseX + pos[0], y: baseY + pos[1], r: pos[2], partIndex, segmentIndex: segIndex });
                            if (isPresent) {
                                sticks.push({ id: `stick_${idCounter++}`, slotId, x: baseX + pos[0], y: baseY + pos[1], rotation: pos[2], color: 'bg-orange-600' });
                            }
                        });
                    } else if (part.type === 'op') {
                        if (part.value === '+' || part.value === '-') {
                            OP_PLUS.forEach((pos, segIndex) => {
                                const type = segIndex === 0 ? 'plus_vert' : 'plus_horiz';
                                const slotId = `slot_${partIndex}_${type}`;
                                slots.push({ id: slotId, x: baseX + pos[0], y: baseY + pos[1], r: pos[2], partIndex, type });
                                
                                let addStick = false;
                                if (part.value === '+') addStick = true;
                                else if (part.value === '-' && segIndex === 1) addStick = true;

                                if (addStick) {
                                    sticks.push({ id: `stick_${idCounter++}`, slotId, x: baseX + pos[0], y: baseY + pos[1], rotation: pos[2], color: 'bg-orange-600' });
                                }
                            });
                        } else {
                            OP_EQUAL.forEach((pos, segIndex) => {
                                const slotId = `slot_${partIndex}_${segIndex}`;
                                slots.push({ id: slotId, x: baseX + pos[0], y: baseY + pos[1], r: pos[2], partIndex });
                                sticks.push({ id: `stick_${idCounter++}`, slotId, x: baseX + pos[0], y: baseY + pos[1], rotation: pos[2] });
                            });
                        }
                    }
                });
            }
            // Dedup slots
            slots = slots.filter((v,i,a)=>a.findIndex(t=>(t.id === v.id))===i);
            return { sticks, slots, shiftX };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown }) => (
            <div onMouseDown={onMouseDown} onTouchStart={onMouseDown}
                style={{
                    position: 'absolute', left: x, top: y, width: '80px', height: '10px',
                    backgroundColor: isDragging ? '#fbbf24' : '#d97706', borderRadius: '5px',
                    transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', cursor: 'pointer',
                    zIndex: isDragging ? 50 : 10, touchAction: 'none'
                }}
                className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
            >
                <div style={{ width: '12px', height: '14px', backgroundColor: '#ef4444', borderRadius: '50%', position: 'absolute', left: '-2px', top: '-2px' }}></div>
                <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
            </div>
        );

        const Slot = ({ x, y, rotation, isShape }) => (
            <div className={isShape ? "slot-dash" : "bg-black/5"}
                style={{
                    position: 'absolute', left: x, top: y, width: '80px', height: '10px',
                    borderRadius: '5px', transform: `rotate(${rotation}deg)`, transformOrigin: '5px 5px', zIndex: 1
                }}
            ></div>
        );

        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing');
            const [hintLevel, setHintLevel] = useState(0);
            const [boardScale, setBoardScale] = useState(1);
            const [levels, setLevels] = useState([]);
            const [shiftX, setShiftX] = useState(0); // Store shift for win checking

            const boardRef = useRef(null);
            const gameAreaRef = useRef(null);

            useEffect(() => {
                setLevels(generateLevelSet());
            }, []);

            const currentLevel = levels.length > 0 ? levels[currentLevelIdx] : null;

            useEffect(() => {
                if (currentLevel) loadLevelData(currentLevel);
            }, [currentLevel]);

            useEffect(() => {
                const handleResize = () => {
                    const w = window.innerWidth;
                    setBoardScale(Math.min(1, (w - 32) / 800));
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const loadLevelData = (levelData) => {
                const { sticks: initSticks, slots: initSlots, shiftX: sX } = generateSticks(levelData);
                setSticks(initSticks);
                setSlots(initSlots);
                setShiftX(sX);
                setMovesCount(0);
                setGameState('playing');
                setHintLevel(0);
            };

            // ... Drag Logic (Same as before) ...
            const handleMove = (e) => {
                if (!draggingId || !boardRef.current) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = boardRef.current.getBoundingClientRect();
                const scale = rect.width / 800;
                setMousePos({ x: (clientX - rect.left) / scale - dragOffset.x, y: (clientY - rect.top) / scale - dragOffset.y });
            };
            const handleUp = () => {
                if (draggingId) { snapStick(draggingId, mousePos.x, mousePos.y); setDraggingId(null); }
            };
            useEffect(() => {
                window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false }); window.addEventListener('touchend', handleUp);
                return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); window.removeEventListener('touchmove', handleMove); window.removeEventListener('touchend', handleUp); };
            }, [draggingId, mousePos, dragOffset]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (boardRef.current) {
                    const rect = boardRef.current.getBoundingClientRect();
                    const scale = rect.width / 800;
                    setDragOffset({ x: (clientX - rect.left) / scale - stickX, y: (clientY - rect.top) / scale - stickY });
                    setMousePos({ x: stickX, y: stickY });
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                let nearest = null, minDist = 50;
                const currentStick = sticks.find(s => s.id === stickId);
                slots.forEach(slot => {
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    if (dist < minDist && !isOccupied) { minDist = dist; nearest = slot; }
                });

                if (nearest) {
                    const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id, rotation: nearest.r } : s);
                    if(currentStick.slotId !== nearest.id) setMovesCount(p => p + 1);
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) setSticks(sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s));
                }
            };

            const checkWinCondition = (currentSticks) => {
                if (!currentLevel) return;

                if (currentLevel.type === 'shape') {
                    // Shape Logic
                    const baseY = 50; 
                    let matchCount = 0;
                    const required = currentLevel.winSlots.length;
                    
                    currentLevel.winSlots.forEach(ws => {
                        const targetX = ws.x + shiftX;
                        const targetY = ws.y + baseY;
                        
                        const hasStick = currentSticks.some(s => 
                            Math.abs(s.x - targetX) < 10 && 
                            Math.abs(s.y - targetY) < 10 &&
                            Math.abs(s.rotation - ws.r) < 5
                        );
                        if (hasStick) matchCount++;
                    });

                    if (matchCount === required && matchCount === currentSticks.length) {
                        setGameState('won');
                        new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                    }

                } else {
                    // Math Logic
                    const filledSlots = {};
                    currentSticks.forEach(s => {
                        const slot = slots.find(sl => sl.id === s.slotId);
                        if (slot) {
                            if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                            if (slot.type === 'plus_vert') filledSlots[slot.partIndex].push('vert');
                            else if (slot.type === 'plus_horiz') filledSlots[slot.partIndex].push('horiz');
                            else filledSlots[slot.partIndex].push(slot.segmentIndex);
                        }
                    });

                    const decodedValues = [], decodedOps = [];
                    let isMalformed = false;

                    currentLevel.layout.forEach((part, idx) => {
                        const segments = filledSlots[idx] || [];
                        if (part.type === 'digit') {
                            let digit = -1;
                            Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                                const a = [...val].sort(), b = [...segments].sort();
                                if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                            });
                            if (digit !== -1) decodedValues.push(digit); else isMalformed = true;
                        } else if (part.type === 'op') {
                            if (part.value === '=') { if (segments.length !== 2) isMalformed = true; }
                            else {
                                const hasVert = segments.includes('vert'), hasHoriz = segments.includes('horiz');
                                if (hasVert && hasHoriz) decodedOps.push('+');
                                else if (!hasVert && hasHoriz) decodedOps.push('-');
                                else isMalformed = true;
                            }
                        }
                    });

                    if (!isMalformed) {
                        try {
                            if (currentLevel.check(decodedValues, decodedOps)) {
                                setGameState('won');
                                new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                            }
                        } catch (e) {}
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < levels.length - 1) setCurrentLevelIdx(p => p + 1);
                else {
                    alert("æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰é—œå¡ï¼30é€±å¹´å¿«æ¨‚ï¼");
                    setLevels(generateLevelSet());
                    setCurrentLevelIdx(0);
                }
            };

            const resetLevel = () => { if(currentLevel) loadLevelData(currentLevel); };

            if (!currentLevel) return <div className="flex h-screen items-center justify-center text-2xl text-orange-600 font-bold">è¼‰å…¥ä¸­...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 w-full max-w-4xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-4 bg-white/80 backdrop-blur p-4 rounded-xl shadow-lg border-b-4 border-orange-300">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-700 tracking-wider">ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</h1>
                            <div className="flex items-center gap-2 mt-2">
                                <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">é—œå¡ {currentLevelIdx + 1}/{levels.length}</span>
                                {currentLevel.id.startsWith('sp') && <span className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm animate-pulse">30é€±å¹´ç‰¹åˆ¥é¡Œ</span>}
                                {currentLevel.type === 'shape' && <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">åœ–å½¢æŒ‘æˆ°</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-xs font-bold uppercase tracking-widest">ç§»å‹•æ¬¡æ•¸</div>
                            <div className="text-3xl font-black text-gray-700">{movesCount}</div>
                        </div>
                    </div>

                    <div className={`border-l-8 p-6 mb-6 w-full rounded-lg shadow-md ${currentLevel.type === 'shape' ? 'bg-blue-50 border-blue-400 text-blue-900' : 'bg-[#fcf8e3] border-yellow-400 text-yellow-800'}`}>
                        <div className="text-lg font-bold mb-1">{currentLevel.title}</div>
                        <div className="text-xl mb-2">{currentLevel.instruction}</div>
                        <div className="text-2xl font-mono bg-white/50 inline-block px-4 py-2 rounded border shadow-inner tracking-widest opacity-80">
                            {currentLevel.formula}
                        </div>
                    </div>

                    <div ref={gameAreaRef} className="relative bg-[#eeeadd] rounded-xl shadow-inner border-4 border-[#d1cbb8] w-full overflow-hidden" style={{ height: '320px', touchAction: 'none' }}>
                        <div className="absolute inset-0 paper-texture"></div>
                        <div ref={boardRef} className="absolute top-[50px] left-1/2 w-[800px] h-[200px] origin-top" style={{ transform: `translateX(-50%) scale(${boardScale})` }}>
                            {slots.map(slot => ( <Slot key={slot.id} x={slot.x} y={slot.y} rotation={slot.r} isShape={currentLevel.type === 'shape'} /> ))}
                            {sticks.map(stick => ( <Stick key={stick.id} x={draggingId === stick.id ? mousePos.x : stick.x} y={draggingId === stick.id ? mousePos.y : stick.y} rotation={stick.rotation} isDragging={draggingId === stick.id} onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)} /> ))}
                        </div>
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-b-8 border-green-500 transform scale-110">
                                    <div className="text-7xl mb-4 float-anim">ğŸ‰</div>
                                    <h2 className="text-4xl font-black text-green-600 mb-2 tracking-tight">ç­”æ¡ˆæ­£ç¢ºï¼</h2>
                                    <button onClick={nextLevel} className="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 flex items-center gap-3 mx-auto">ä¸‹ä¸€é—œ âœ</button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow-lg border border-gray-100">
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2"><span className="text-xl">ğŸ’¡</span> æç¤º</h3>
                                <div className="flex gap-2">
                                    <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 1 ? 'bg-gray-100 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}>LV 1</button>
                                    <button onClick={() => setHintLevel(2)} disabled={hintLevel >= 2 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 2 ? 'bg-gray-100 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}>LV 2</button>
                                </div>
                            </div>
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-4 rounded-lg border border-gray-100 leading-relaxed">
                                {hintLevel === 0 && "å¦‚æœåœ¨è§£é¡Œæ™‚é‡åˆ°å›°é›£ï¼Œå¯ä»¥æŒ‰ä¸Šæ–¹æŒ‰éˆ•ç²å¾—æç¤ºã€‚"}
                                {hintLevel >= 1 && (<div className="animate-pulse text-blue-700 font-medium mb-2 flex items-start gap-2"><span>ğŸ”¹</span> {currentLevel.hint1}</div>)}
                                {hintLevel >= 2 && (<div className="text-purple-700 font-bold flex items-start gap-2"><span>ğŸ”¸</span> {currentLevel.hint2}</div>)}
                            </div>
                        </div>
                        <div className="flex flex-col gap-3">
                            <button onClick={resetLevel} className="flex-1 bg-white hover:bg-gray-50 text-gray-700 font-bold py-3 rounded-xl border-b-4 border-gray-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">ğŸ”„ é‡ç½®æœ¬é—œ</button>
                            <button onClick={nextLevel} className="flex-1 bg-red-50 hover:bg-red-100 text-red-600 font-bold py-3 rounded-xl border-b-4 border-red-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">â© è·³éæœ¬é—œ</button>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
