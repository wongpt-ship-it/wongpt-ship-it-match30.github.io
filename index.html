<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‰∏âÂçÅÂë®Âπ¥ÁÅ´Êü¥Â§ßÊåëÊà∞</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #fef3c7;
            user-select: none;
            -webkit-user-select: none;
        }
        
        .wood-texture {
            background-color: #d97706;
            background-image: url("data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='%23b45309' fill-opacity='0.4' fill-rule='evenodd'%3E%3Cpath d='M0 38.59l2.83-2.83 1.41 1.41L1.41 40H0v-1.41zM0 1.4l2.83 2.83 1.41-1.41L1.41 0H0v1.41zM38.59 40l-2.83-2.83 1.41-1.41L40 38.59V40h-1.41zM40 1.41l-2.83 2.83-1.41-1.41L38.59 0H40v1.41zM20 18.6l2.83-2.83 1.41 1.41L21.41 20H20v-1.41zM20 21.4l2.83 2.83 1.41-1.41L21.41 20H20v1.41z'/%3E%3C/g%3E%3C/svg%3E");
        }

        .stick-shadow {
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        }

        /* Prevent text selection */
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Data & Configuration ---

        // 7-segment representation: 
        //   0
        // 1   2
        //   3
        // 4   5
        //   6
        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] // or [0,1,2,3,5]
        };

        // Positions for segments in a 100x180 box
        // [x, y, rotation(0=horiz, 90=vert)]
        const SEGMENT_POSITIONS = [
            [20, 0, 0],   // 0: Top
            [10, 20, 90], // 1: Top-Left
            [90, 20, 90], // 2: Top-Right
            [20, 80, 0],  // 3: Middle
            [10, 100, 90],// 4: Bottom-Left
            [90, 100, 90],// 5: Bottom-Right
            [20, 160, 0]  // 6: Bottom
        ];

        const OP_PLUS = [
            [40, 50, 90], // Vertical
            [10, 80, 0]   // Horizontal
        ];
        
        const OP_MINUS = [
            [10, 80, 0]
        ];

        const OP_EQUAL = [
            [10, 65, 0],
            [10, 95, 0]
        ];

        // Level Definitions
        // format: type: 'eq' (equation), parts: array of {type: 'digit'|'op', val: initialValue, id: unique}
        // solution: validation function or target state
        const LEVELS = [
            {
                id: 1,
                title: "ÁÜ±Ë∫´È°å",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "6 + 4 = 4",
                hint1: "ÁµêÊûúÁöÑ 4 ÊòØ‰∏çÈúÄË¶ÅËÆäÂãïÁöÑÔºåË©¶ËëóÊää 6 ËÆäÊàêÂÖ∂‰ªñÊï∏Â≠ó„ÄÇ",
                hint2: "Êää 6 ÁöÑÂ∑¶‰∏ãËßíÁÅ´Êü¥ÁßªÂà∞‰∏≠ÈñìÔºåËÆäÊàê 0„ÄÇ",
                layout: [
                    { type: 'digit', value: 6, x: 50 },
                    { type: 'op', value: '+', x: 180 },
                    { type: 'digit', value: 4, x: 280 },
                    { type: 'op', value: '=', x: 410 },
                    { type: 'digit', value: 4, x: 510 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] // 0 + 4 = 4
            },
            {
                id: 2,
                title: "Âä†Ê∏õÊ≥ï",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "8 + 3 = 5", // Invalid
                hint1: "Ë©¶Ë©¶ÁúãÊîπËÆäÈÅãÁÆóÁ¨¶Ëôü„ÄÇ",
                hint2: "Êää 8 ‰∏≠ÈñìÁöÑÁÅ´Êü¥ÁßªÂà∞ 5 ÁöÑÁº∫Âè£ËÆäÊàê 9Ôºå8 ËÆäÊàê 0? ‰∏çÂ∞ç„ÄÇË©¶Ë©¶ 9-3=6? Ë©¶Ë©¶ 8-3=5„ÄÇ",
                // Wait, 8-3=5 requires moving 1 stick from (+) to make it (-) and putting it somewhere?
                // Actually 9-3=6 is 1 move? 8->9 (needs 1), 5->6 (needs 1). No.
                // Let's use: 9 + 3 = 5 -> 3 + 2 = 5 (Move 2? No).
                // Let's use: 8 - 5 = 3 is valid.
                // Target: 9 - 5 = 8 (Move 1). 
                // Formula: 9 - 5 = 8. Move 1 to make 3 + 5 = 8? 
                // Move 9->3 (1 stick), - -> + (1 stick). That's 2 moves within the same group?
                // Let's go with simpler: 5 + 5 = 8 -> 3 + 5 = 8 (Move 1? No 5->3 is remove top-left, add top-right. 2 moves).
                // Classic: 6 + 4 = 4 (Done).
                // 1 + 1 = 5? -> 4 + 1 = 5? (1->4 needs 2).
                // How about 7 - 1 = 1 -> 1 + 1 = 2 (Too many moves).
                // Let's use: 3 + 3 = 8 -> 5 + 3 = 8 (Move 1 stick: 3->5 is 1 move: top-right to top-left).
                formula: "3 + 3 = 8",
                hint1: "8 ÂæàÂ§ßÔºå‰∏çÈúÄË¶ÅËÆäÂãï„ÄÇÂòóË©¶ÊääÂÖ∂‰∏≠‰∏ÄÂÄã 3 ËÆäÂ§ß„ÄÇ",
                hint2: "ÊääÁ¨¨‰∏ÄÂÄã 3 ÁöÑÂè≥‰∏äËßíÁÅ´Êü¥ÁßªÂà∞Â∑¶‰∏äËßíÔºåËÆäÊàê 5„ÄÇ",
                layout: [
                    { type: 'digit', value: 3, x: 50 },
                    { type: 'op', value: '+', x: 180 },
                    { type: 'digit', value: 3, x: 280 },
                    { type: 'op', value: '=', x: 410 },
                    { type: 'digit', value: 8, x: 510 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] // 5 + 3 = 8
            },
            {
                id: 3,
                title: "Ê∏õÊ≥ïÊåëÊà∞",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "9 - 5 = 8", 
                // 9-5=4. 
                // Target: 6+5=11? No.
                // 8-5=3? 9->8 (1 move? No, 9 is 6 segs, 8 is 7. Need add).
                // 5+5=0? No.
                // How about: 8 - 9 = 5 -> -1? No.
                // Let's try: 8 + 3 = 11 (2 digits result).
                // Let's try: 9 + 6 = 13?
                // Puzzle: 14 - 7 = 1? -> 14 - 7 = 7 (Move 1 -> 1 to make 7? No).
                // Puzzle: 7 + 1 = 1. (Move 1). -> 1 - 1 = 0? (7->1 remove 2. No).
                // Back to basics: 
                // 6 - 4 = 4 (Invalid).
                // Correct is 8 - 4 = 4. (6->8 add 1). Where from? - -> +? 8+4 != 4.
                // How about 0 + 4 = 4. (6->0 is move 1). Wait we did that in LV1.
                // Let's do: 5 + 7 = 2 -> 9 - 7 = 2. (5->9 add 1. + -> - take 1. Total 1 move).
                formula: "5 + 7 = 2",
                hint1: "Âä†Ê≥ïËÆäÊ∏õÊ≥ïÔºü",
                hint2: "ÊääÂä†ËôüÁöÑ‰∏ÄÊ†πÁÅ´Êü¥ÁßªÂà∞ 5 ‰∏äÔºåËÆìÂÆÉËÆäÊàê 9„ÄÇ",
                layout: [
                    { type: 'digit', value: 5, x: 50 },
                    { type: 'op', value: '+', x: 180 },
                    { type: 'digit', value: 7, x: 280 },
                    { type: 'op', value: '=', x: 410 },
                    { type: 'digit', value: 2, x: 510 }
                ],
                maxMoves: 1,
                check: (values, ops) => {
                     // Need to check operators too here since one changed
                     // But our simple check assumes structure. We need to detect op change.
                     // The game logic will parse the sticks to determine current values and ops.
                     return values[0] - values[2] === values[4];
                }
            },
            {
                id: 4,
                title: "Êï∏Â≠óËÆäË∫´",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "9 + 3 = 6", 
                // Target: 3 + 3 = 6 (9->3 move 1? 9(6 segs) -> 3(5 segs). Remove 1. Where? 6->8? 3+3=8. No).
                // 5 + 3 = 8? (9->5 move 1. 6->8 move ?).
                // How about 8 - 3 = 5. (9->8 add 1? No).
                // Let's use: 0 + 3 = 3? (9->0 move 1? 9 has mid, 0 no mid. 9 has no bot-left, 0 has. Yes, move mid to bot-left).
                // So 9+3=6 -> 0+3=3? No 6!=3.
                // 9-3=6. (+ -> -). Where does the stick go? 6->8. 9-3=6 -> 9-3=6 is correct.
                // Start: 9 + 3 = 6. Move + to 6 -> 8. Result 9 - 3 = 6. Correct.
                hint1: "ÁµêÊûú 6 ‰ºº‰πéÂ∞ë‰∫Ü‰∏ÄÊ†πÁÅ´Êü¥„ÄÇ",
                hint2: "ÊääÂä†ËôüÁöÑ‰∏ÄÊ†πÁÅ´Êü¥ÁßªÂà∞ 6 ‰∏äÔºåËÆäÊàê 8Ôºå‰∏¶ËÆìÈÅãÁÆóËÆäÊàêÊ∏õÊ≥ï„ÄÇ",
                layout: [
                    { type: 'digit', value: 9, x: 50 },
                    { type: 'op', value: '+', x: 180 },
                    { type: 'digit', value: 3, x: 280 },
                    { type: 'op', value: '=', x: 410 },
                    { type: 'digit', value: 6, x: 510 }
                ],
                maxMoves: 1,
                check: (values) => values[0] - values[2] === values[4] // 9 - 3 = 6
            },
            {
                id: 5,
                title: "ÁÑ°‰∏≠ÁîüÊúâ",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "3 + 9 = 6",
                // 3 + 3 = 6. (9->3 move 1? 9 is 6 segs, 3 is 5. Remove 1. Where? 6->8. 3+3=8? No).
                // How about 3 + 5 = 8. (9->5 move 1: top-right to top-left? No 9 has top-left. 9(TR,TL,T,M,B,BR). 5(T,TL,M,BR,B). 9->5 is remove TR. Place somewhere. 6->8. 3+5=8. Correct).
                hint1: "Ë©¶ËëóÊää 9 ËÆäÊàê 5„ÄÇ",
                hint2: "Êää 9 ÁöÑÂè≥‰∏äËßíÁÅ´Êü¥ÁßªÂà∞ 6 ÁöÑÁº∫Âè£ÔºåËÆäÊàê 8„ÄÇ",
                layout: [
                    { type: 'digit', value: 3, x: 50 },
                    { type: 'op', value: '+', x: 180 },
                    { type: 'digit', value: 9, x: 280 },
                    { type: 'op', value: '=', x: 410 },
                    { type: 'digit', value: 6, x: 510 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] // 3 + 5 = 8
            },
            // --- 30th Anniversary Levels ---
            {
                id: 6,
                title: "‰∏âÂçÅËÄåÁ´ã (‰∏Ä)",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁµêÊûúÁ≠âÊñº 30",
                formula: "26 + 4 = 20",
                // Target: 26 + 4 = 30.
                // Move 1 from 20 -> 30. (2->3). 2 is [0,2,3,4,6], 3 is [0,2,3,5,6]. Move 4(bot-left) to 5(bot-right).
                hint1: "È°åÁõÆË¶ÅÊ±ÇÁµêÊûúÊòØ 30ÔºåÁúãÁúãÁ≠îÊ°àÈÉ®ÂàÜ„ÄÇ",
                hint2: "ÊääÁ≠îÊ°à 20 ÁöÑ 2 ËÆäÊàê 3„ÄÇÁßªÂãïÂ∑¶‰∏ãËßíÁöÑÁÅ´Êü¥Âà∞Âè≥‰∏ãËßí„ÄÇ",
                layout: [
                    { type: 'digit', value: 2, x: 50 },
                    { type: 'digit', value: 6, x: 130 },
                    { type: 'op', value: '+', x: 240 },
                    { type: 'digit', value: 4, x: 320 },
                    { type: 'op', value: '=', x: 430 },
                    { type: 'digit', value: 2, x: 530 },
                    { type: 'digit', value: 0, x: 610 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) + values[2] === 30 // 26 + 4 = 30
            },
            {
                id: 7,
                title: "‰∏âÂçÅËÄåÁ´ã (‰∫å)",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁµêÊûúÁ≠âÊñº 30",
                formula: "36 - 6 = 36",
                // Target: 36 - 6 = 30.
                // Move 36 (answer) -> 30. 6->0. Move mid to bot-left?
                // 6 [0,1,3,4,5,6], 0 [0,1,2,4,5,6]. No, 6->0 is move Middle to Top-Right.
                hint1: "36 Ê∏õ 6 ÊáâË©≤Á≠âÊñºÂ§öÂ∞ëÔºü",
                hint2: "ÊääÁ≠îÊ°à 36 ÁöÑ 6 ‰∏≠ÈñìÈÇ£Ê†πÁÅ´Êü¥ÁßªÂà∞Âè≥‰∏äËßíÔºåËÆäÊàê 0„ÄÇ",
                layout: [
                    { type: 'digit', value: 3, x: 50 },
                    { type: 'digit', value: 6, x: 130 },
                    { type: 'op', value: '-', x: 240 },
                    { type: 'digit', value: 6, x: 320 },
                    { type: 'op', value: '=', x: 430 },
                    { type: 'digit', value: 3, x: 530 },
                    { type: 'digit', value: 6, x: 610 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 8,
                title: "‰∏âÂçÅËÄåÁ´ã (‰∏â)",
                instruction: "ÁßªÂãï 2 Ê†πÁÅ´Êü¥ÔºåÂÅöÂá∫ 30",
                formula: "18 + 12 = 38",
                // Target: 18 + 12 = 30.
                // 38 -> 30. 8->0 is remove middle. 1 move.
                // But instruction says move 2? Let's make it Move 1.
                // Wait, 18+12=30 is correct mathematically.
                // So we just need to change result 38 to 30. 8->0 is 1 move (remove middle). Where does it go?
                // Just remove? No, standard rule is rearrange.
                // 18 + 12 = 30. 8->0 (1 stick). Where to put?
                // Make 18 -> 18? No. 
                // Make 12 -> 18? (2->8 need 2 sticks).
                // Let's try: 15 + 15 = 38 -> 15 + 15 = 30. (8->0 remove mid. Put where? 5->9? 15+19=34. No).
                // Let's try: 35 - 5 = 39 -> 35 - 5 = 30. (9->0 add 1 stick? No 9->0 is move mid to bot-left. 1 move).
                // So 35-5=39 (invalid). Target 35-5=30. Move 9->0 (Mid -> Bot-left).
                formula: "35 - 5 = 39",
                hint1: "35 Ê∏õ 5 ÊáâË©≤ÊòØ 30„ÄÇ",
                hint2: "Êää 39 ÁöÑ 9 ËÆäÊàê 0„ÄÇÁßªÂãï‰∏≠ÈñìÁöÑÁÅ´Êü¥Âà∞Â∑¶‰∏ãËßí„ÄÇ",
                layout: [
                    { type: 'digit', value: 3, x: 50 },
                    { type: 'digit', value: 5, x: 130 },
                    { type: 'op', value: '-', x: 240 },
                    { type: 'digit', value: 5, x: 320 },
                    { type: 'op', value: '=', x: 430 },
                    { type: 'digit', value: 3, x: 530 },
                    { type: 'digit', value: 9, x: 610 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 9,
                title: "‰∏âÂçÅÂë®Âπ¥ (Âõõ)",
                instruction: "ÁßªÂãï 1 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "39 - 9 = 36", // 30
                // 39-9=30. 
                // 36->30. 6->0 is move mid to top-right.
                hint1: "ÈÄôÊòØ‰∏ÄÊ¢ùÁ∞°ÂñÆÁöÑÊ∏õÊ≥ï„ÄÇ",
                hint2: "Êää 36 ÁöÑ 6 ËÆäÊàê 0„ÄÇ",
                layout: [
                    { type: 'digit', value: 3, x: 50 },
                    { type: 'digit', value: 9, x: 130 },
                    { type: 'op', value: '-', x: 240 },
                    { type: 'digit', value: 9, x: 320 },
                    { type: 'op', value: '=', x: 430 },
                    { type: 'digit', value: 3, x: 530 },
                    { type: 'digit', value: 6, x: 610 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 10,
                title: "‰∏âÂçÅÂë®Âπ¥ (ÁµÇÊ•µ)",
                instruction: "ÁßªÂãï 2 Ê†πÁÅ´Êü¥Ôºå‰ΩøÁ≠âÂºèÊàêÁ´ã",
                formula: "11 + 19 = 80",
                // Target: 11 + 19 = 30.
                // 80 -> 30. 8->3.
                // 8 is all 7. 3 is [0,2,3,5,6]. Remove 1(TL) and 4(BL).
                // We have 2 sticks removed.
                // Where to put? Maybe we don't need to put them back if we 'remove' them?
                // Prompt says "Move". Usually implies conservation of mass.
                // Let's find a conservation puzzle.
                // 25 + 5 = 30.
                // Start: 25 + 5 = 80? (3->8 needs 2).
                // Let's try 5 * 6 = 30.
                // Start 6 * 5 = 30?
                // Let's do: 30 + 0 = 30.
                // Start: 38 - 8 = 30.
                // Start: 38 - 8 = 38. (Move 1: 38->30. 8->0 is 1 remove? No 8->0 is remove mid. 1 stick floating).
                // Let's go back to: 14 + 16 = 30.
                // Puzzle: 74 - 44 = 30.
                // Puzzle: 30 = 30.
                // Let's try a tricky one: make the number 30 from "38". (Remove sticks?).
                // Let's stick to the prompt's implied mechanics: Move sticks.
                // 6 + 24 = 30.
                // Start: 5 + 25 = 30.
                // Let's try: 15 + 15 = 30.
                // Start: 19 - 4 = 15? No.
                // Let's do: 15 + 15 = 50. (5->3 is 1 move? 5 to 3: Move TL to BR? No 5 has BR. 5 is T,TL,M,BR,B. 3 is T,TR,M,BR,B. Move TL to TR. 1 move. 5->3).
                // So 15 + 15 = 50 -> 15 + 15 = 30. 
                // 50 -> 30. 5->3. Move TL to TR.
                // Perfect.
                hint1: "15 Âä† 15 Á≠âÊñºÂ§öÂ∞ëÔºü",
                hint2: "ÊääÁ≠îÊ°à 50 ÁöÑ 5 ËÆäÊàê 3„ÄÇÂ∞áÂ∑¶‰∏äËßíÁöÑÁÅ´Êü¥ÁßªÂà∞Âè≥‰∏äËßí„ÄÇ",
                layout: [
                    { type: 'digit', value: 1, x: 50 },
                    { type: 'digit', value: 5, x: 130 },
                    { type: 'op', value: '+', x: 240 },
                    { type: 'digit', value: 1, x: 320 },
                    { type: 'digit', value: 5, x: 400 },
                    { type: 'op', value: '=', x: 510 },
                    { type: 'digit', value: 5, x: 610 },
                    { type: 'digit', value: 0, x: 690 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) + (values[2]*10 + values[3]) === 30
            }
        ];

        // --- Helpers ---

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = []; // Places where sticks CAN go (ghost slots)
            let idCounter = 0;

            levelData.layout.forEach((part, partIndex) => {
                let baseX = part.x;
                let baseY = 100; // Center Y vertically roughly
                
                if (part.type === 'digit') {
                    // Create all 7 slots for this digit position
                    SEGMENT_POSITIONS.forEach((pos, segIndex) => {
                        const slotId = `slot_${partIndex}_${segIndex}`;
                        const isPresent = DIGIT_MAP[part.value].includes(segIndex);
                        
                        slots.push({
                            id: slotId,
                            x: baseX + pos[0],
                            y: baseY + pos[1],
                            rotation: pos[2],
                            partIndex: partIndex, // Which digit/op this belongs to
                            segmentIndex: segIndex // Which segment of the digit
                        });

                        if (isPresent) {
                            sticks.push({
                                id: `stick_${idCounter++}`,
                                slotId: slotId,
                                x: baseX + pos[0],
                                y: baseY + pos[1],
                                rotation: pos[2],
                                color: 'bg-orange-600'
                            });
                        }
                    });
                } else if (part.type === 'op') {
                    // Operations
                    let positions = part.value === '+' ? OP_PLUS : (part.value === '-' ? OP_MINUS : OP_EQUAL);
                    // Special handling: Minus can become Plus (needs vertical slot ghost)
                    // Plus can become Minus (needs vertical slot ghost)
                    // Equal usually stays equal but could technically change? Let's assume structure fixed for ops mainly,
                    // EXCEPT: Minus <-> Plus is a common trope.
                    // So if it's + or -, generate BOTH slots (horiz and vert).
                    
                    if (part.value === '+' || part.value === '-') {
                         OP_PLUS.forEach((pos, segIndex) => {
                            const slotId = `slot_${partIndex}_${segIndex}`;
                            // Check if this segment exists in current value
                            // Plus: has both index 0 (vert) and 1 (horiz) in OP_PLUS array order?
                            // My OP_PLUS: 0=Vert, 1=Horiz.
                            // OP_MINUS: 0=Horiz.
                            // Let's standardize: 0=Vert, 1=Horiz.
                            
                            // Let's manually define slots for +/-
                            // Vert slot
                            slots.push({
                                id: `slot_${partIndex}_vert`,
                                x: baseX + 40, y: baseY + 50, rotation: 90,
                                partIndex, type: 'plus_vert'
                            });
                            // Horiz slot
                            slots.push({
                                id: `slot_${partIndex}_horiz`,
                                x: baseX + 10, y: baseY + 80, rotation: 0,
                                partIndex, type: 'plus_horiz'
                            });

                            // Add sticks
                            if (part.value === '+') {
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_vert`, x: baseX + 40, y: baseY + 50, rotation: 90 });
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_horiz`, x: baseX + 10, y: baseY + 80, rotation: 0 });
                            } else {
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_horiz`, x: baseX + 10, y: baseY + 80, rotation: 0 });
                            }
                        });
                    } else {
                        // Equal sign
                         OP_EQUAL.forEach((pos, segIndex) => {
                             const slotId = `slot_${partIndex}_${segIndex}`;
                             slots.push({
                                 id: slotId,
                                 x: baseX + pos[0],
                                 y: baseY + pos[1],
                                 rotation: pos[2],
                                 partIndex
                             });
                             sticks.push({
                                 id: `stick_${idCounter++}`,
                                 slotId: slotId,
                                 x: baseX + pos[0],
                                 y: baseY + pos[1],
                                 rotation: pos[2]
                             });
                         });
                    }
                }
            });
            // Filter duplicate slots if any (due to loops)
            slots = slots.filter((v,i,a)=>a.findIndex(t=>(t.id === v.id))===i);
            return { sticks, slots };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown, color }) => {
            return (
                <div
                    onMouseDown={onMouseDown}
                    onTouchStart={onMouseDown}
                    style={{
                        position: 'absolute',
                        left: x,
                        top: y,
                        width: '80px',
                        height: '10px',
                        backgroundColor: isDragging ? '#fbbf24' : '#d97706', // Amber-400 drag, Amber-600 normal
                        borderRadius: '5px',
                        transform: `rotate(${rotation}deg)`,
                        transformOrigin: '5px 5px', // Pivot around start
                        cursor: 'pointer',
                        zIndex: isDragging ? 50 : 10,
                        touchAction: 'none'
                    }}
                    className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
                >
                    {/* Match head */}
                    <div style={{
                        width: '12px',
                        height: '14px',
                        backgroundColor: '#ef4444', // Red-500
                        borderRadius: '50%',
                        position: 'absolute',
                        left: '-2px',
                        top: '-2px'
                    }}></div>
                    
                    {/* Wood grain effect details */}
                    <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
                </div>
            );
        };

        const Slot = ({ x, y, rotation }) => {
            return (
                <div
                    style={{
                        position: 'absolute',
                        left: x,
                        top: y,
                        width: '80px',
                        height: '10px',
                        backgroundColor: 'rgba(0,0,0,0.05)',
                        borderRadius: '5px',
                        transform: `rotate(${rotation}deg)`,
                        transformOrigin: '5px 5px',
                        zIndex: 1
                    }}
                ></div>
            );
        };

        // Main Game Component
        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing'); // playing, won
            const [hintLevel, setHintLevel] = useState(0); // 0: none, 1: text, 2: highlight
            const gameAreaRef = useRef(null);

            const currentLevel = LEVELS[currentLevelIdx];

            // Initialize level
            useEffect(() => {
                loadLevel(currentLevelIdx);
            }, [currentLevelIdx]);

            const loadLevel = (idx) => {
                const { sticks: initSticks, slots: initSlots } = generateSticks(LEVELS[idx]);
                setSticks(initSticks);
                setSlots(initSlots);
                setMovesCount(0);
                setGameState('playing');
                setHintLevel(0);
            };

            // Global mouse/touch move for dragging
            useEffect(() => {
                const handleMove = (e) => {
                    if (!draggingId) return;
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    if (gameAreaRef.current) {
                        const rect = gameAreaRef.current.getBoundingClientRect();
                        // Calculate position relative to game area
                        // Apply scaling factor if game area is scaled? Assuming 1:1 for now or responsive css handles it
                        // We need the raw coordinates inside the relative container
                        
                        setMousePos({
                            x: clientX - rect.left - dragOffset.x,
                            y: clientY - rect.top - dragOffset.y
                        });
                    }
                };

                const handleUp = () => {
                    if (draggingId) {
                        snapStick(draggingId, mousePos.x, mousePos.y);
                        setDraggingId(null);
                    }
                };

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleUp);

                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleUp);
                };
            }, [draggingId, mousePos, dragOffset, slots]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault(); // Stop text selection
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (gameAreaRef.current) {
                    const rect = gameAreaRef.current.getBoundingClientRect();
                    // Offset logic to grab stick exactly where clicked
                    // Current stick logic draws at x,y.
                    // Click happened at clientX.
                    // Stick is at rect.left + x.
                    const offsetX = clientX - (rect.left + stickX);
                    const offsetY = clientY - (rect.top + stickY);
                    
                    setDragOffset({ x: offsetX, y: offsetY });
                    setMousePos({ x: stickX, y: stickY }); // Initial visual pos
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                // Find nearest empty slot
                let nearest = null;
                let minDist = 50; // Snap threshold

                // Get current stick details
                const currentStick = sticks.find(s => s.id === stickId);
                
                slots.forEach(slot => {
                    // Calculate distance
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    
                    // Check if slot is occupied by ANOTHER stick
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    
                    // Check rotation match? Usually horizontal stick goes to horiz slot.
                    // Let's enforce rotation match for simplicity, otherwise it looks weird
                    const rotDiff = Math.abs(currentStick.rotation - slot.rotation);
                    const isRotMatch = rotDiff < 10 || rotDiff > 350; // approx equal

                    if (dist < minDist && !isOccupied && isRotMatch) {
                        minDist = dist;
                        nearest = slot;
                    }
                });

                if (nearest) {
                    // Update stick position
                    const newSticks = sticks.map(s => {
                        if (s.id === stickId) {
                            // If slot changed, increment move count (half move? logic: pick up and drop different place)
                            // We can just count every drop to a NEW slot as a move
                            if (s.slotId !== nearest.id) {
                                setMovesCount(prev => prev + 1);
                            }
                            return { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id };
                        }
                        return s;
                    });
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    // Return to original slot
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) {
                        const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s);
                        setSticks(newSticks);
                    }
                }
            };

            const checkWinCondition = (currentSticks) => {
                // Parse the board
                // Map sticks to slots, slots to parts
                // 1. Group filled slots by partIndex
                const filledSlots = {}; // { partIndex: [segIdx, segIdx...] }
                
                currentSticks.forEach(s => {
                    const slot = slots.find(sl => sl.id === s.slotId);
                    if (slot) {
                        if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                        
                        // Handle special +/- slots
                        if (slot.type === 'plus_vert') filledSlots[slot.partIndex].push('vert');
                        else if (slot.type === 'plus_horiz') filledSlots[slot.partIndex].push('horiz');
                        else filledSlots[slot.partIndex].push(slot.segmentIndex);
                    }
                });

                // 2. Decode parts
                const decodedValues = [];
                const decodedOps = []; // Not really used in logic validation except implicit order
                
                let isMalformed = false;

                currentLevel.layout.forEach((part, idx) => {
                    const segments = filledSlots[idx] || [];
                    
                    if (part.type === 'digit') {
                        // Find match in DIGIT_MAP
                        let digit = -1;
                        Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                            // Arrays compare
                            // Sort both
                            const a = [...val].sort();
                            const b = [...segments].sort();
                            if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                        });
                        if (digit !== -1) decodedValues.push(digit);
                        else isMalformed = true;
                    } else if (part.type === 'op') {
                        if (part.value === '=') {
                            // Equals must have 2 lines usually top/bottom. 
                            // My slots: 0(top), 1(bot).
                            if (segments.length === 2) { /* ok */ }
                            else isMalformed = true; // Strict equal sign?
                        } else {
                            // + or -
                            // + needs vert and horiz
                            // - needs horiz
                            const hasVert = segments.includes('vert');
                            const hasHoriz = segments.includes('horiz');
                            
                            if (hasVert && hasHoriz) decodedOps.push('+');
                            else if (!hasVert && hasHoriz) decodedOps.push('-');
                            else isMalformed = true;
                        }
                    }
                });

                if (!isMalformed) {
                    // We only extract DIGIT values for the check function
                    // The operations are assumed to be in the same order usually, OR we handle logic changes
                    // The level.check function currently expects [d1, d2, d3] etc.
                    // Ops changes are tricky. For levels where op changes (level 3, 4), we need to handle it.
                    // Let's pass (values, ops) to check?
                    
                    // Simple hack: Assume layout order is Digit Op Digit = Digit
                    // Values array will contain [d1, d2, d3]
                    // Ops check logic inside check() if needed, or check() just does math
                    // But if Op changed from + to -, the math changes.
                    // Let's reconstruct the equation string and eval it? safer.
                    
                    try {
                        if (currentLevel.check(decodedValues, decodedOps)) {
                            setGameState('won');
                            // Play sound
                            const audio = new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg');
                            audio.volume = 0.5;
                            audio.play().catch(e=>{});
                        }
                    } catch (e) {
                        // Index out of bounds if missing digits
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < LEVELS.length - 1) {
                    setCurrentLevelIdx(prev => prev + 1);
                } else {
                    alert("ÊÅ≠ÂñúÔºÅ‰Ω†Â∑≤ÂÆåÊàêÊâÄÊúâÈóúÂç°ÔºÅ30Âë®Âπ¥Âø´Ê®ÇÔºÅ");
                    setCurrentLevelIdx(0);
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 overflow-hidden w-full max-w-4xl mx-auto">
                    {/* Header */}
                    <div className="w-full flex justify-between items-center mb-4 bg-white p-4 rounded-xl shadow-lg border-2 border-orange-200">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-600">‰∏âÂçÅÂë®Âπ¥ÁÅ´Êü¥Â§ßÊåëÊà∞</h1>
                            <div className="flex items-center gap-2 mt-1">
                                <span className="bg-orange-100 text-orange-800 px-2 py-1 rounded text-sm font-bold">ÂÖ≥Âç° {currentLevelIdx + 1}/10</span>
                                {currentLevelIdx >= 5 && <span className="bg-red-100 text-red-800 px-2 py-1 rounded text-sm font-bold">30Âë®Âπ¥ÁâπÂà•È°å</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-sm">ÁßªÂãïÊ¨°Êï∏</div>
                            <div className="text-2xl font-bold text-gray-700">{movesCount}</div>
                        </div>
                    </div>

                    {/* Instruction */}
                    <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 w-full rounded shadow-sm">
                        <p className="font-bold">{currentLevel.title}</p>
                        <p>{currentLevel.instruction}</p>
                        <p className="text-sm mt-1 text-gray-500 font-mono">{currentLevel.formula}</p>
                    </div>

                    {/* Game Board */}
                    <div 
                        ref={gameAreaRef}
                        className="relative bg-white rounded-xl shadow-inner border-4 border-orange-300 w-full overflow-hidden"
                        style={{ height: '300px', touchAction: 'none' }} // Fixed height for area
                    >
                        {/* Grid/Background */}
                        <div className="absolute inset-0 opacity-10" 
                            style={{backgroundImage: 'radial-gradient(#fbbf24 1px, transparent 1px)', backgroundSize: '20px 20px'}}>
                        </div>

                        {/* Rendering Offset Container to Center Content */}
                        <div style={{ 
                            position: 'absolute', 
                            top: '50px', 
                            left: '50%', 
                            transform: 'translateX(-50%) scale(0.6) sm:scale(0.8)', // Responsive scaling
                            width: '800px', // base width of logic
                            height: '200px'
                        }} className="transform origin-top md:scale-90 lg:scale-100">
                            
                            {/* Slots (Ghosts) */}
                            {slots.map(slot => (
                                <Slot key={slot.id} {...slot} />
                            ))}

                            {/* Sticks */}
                            {sticks.map(stick => (
                                <Stick 
                                    key={stick.id}
                                    x={draggingId === stick.id ? mousePos.x : stick.x}
                                    y={draggingId === stick.id ? mousePos.y : stick.y}
                                    rotation={stick.rotation}
                                    isDragging={draggingId === stick.id}
                                    onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)}
                                />
                            ))}
                        </div>
                        
                        {/* Win Overlay */}
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-4 border-green-500 transform scale-110">
                                    <div className="text-6xl mb-4 float-anim">üéâ</div>
                                    <h2 className="text-3xl font-bold text-green-600 mb-2">Á≠îÊ°àÊ≠£Á¢∫ÔºÅ</h2>
                                    <p className="text-gray-600 mb-6">Â§™Âé≤ÂÆ≥‰∫ÜÔºÅ</p>
                                    <button 
                                        onClick={nextLevel}
                                        className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transform transition hover:scale-105 active:scale-95"
                                    >
                                        ‰∏ã‰∏ÄÈóú
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Controls */}
                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow border border-gray-200">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="font-bold text-gray-700">üí° ÊèêÁ§∫</h3>
                                <div className="space-x-2">
                                    <button 
                                        onClick={() => setHintLevel(1)}
                                        disabled={hintLevel >= 1 || gameState === 'won'}
                                        className={`px-3 py-1 rounded text-sm font-bold transition ${hintLevel >= 1 ? 'bg-gray-200 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}
                                    >
                                        ÊèêÁ§∫ I
                                    </button>
                                    <button 
                                        onClick={() => setHintLevel(2)}
                                        disabled={hintLevel >= 2 || gameState === 'won'}
                                        className={`px-3 py-1 rounded text-sm font-bold transition ${hintLevel >= 2 ? 'bg-gray-200 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}
                                    >
                                        ÊèêÁ§∫ II
                                    </button>
                                </div>
                            </div>
                            
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-3 rounded">
                                {hintLevel === 0 && "Â¶ÇÊûúÂú®Ëß£È°åÊôÇÈÅáÂà∞Âõ∞Èõ£ÔºåÂèØ‰ª•Êåâ‰∏äÊñπÊåâÈàïÁç≤ÂæóÊèêÁ§∫„ÄÇ"}
                                {hintLevel >= 1 && (
                                    <div className="animate-pulse text-blue-800 font-medium mb-1">
                                        LV1: {currentLevel.hint1}
                                    </div>
                                )}
                                {hintLevel >= 2 && (
                                    <div className="text-purple-800 font-bold">
                                        LV2: {currentLevel.hint2}
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="flex flex-col gap-2">
                            <button 
                                onClick={() => loadLevel(currentLevelIdx)}
                                className="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-3 rounded-xl border border-gray-300 transition flex items-center justify-center gap-2"
                            >
                                üîÑ ÈáçÁΩÆÊú¨Èóú
                            </button>
                            {/* Debug Skip */}
                            {/* <button 
                                onClick={nextLevel} 
                                className="flex-1 bg-red-50 text-red-300 text-xs"
                            >Skip (Debug)</button> 
                            */}
                        </div>
                    </div>
                    
                    <div className="mt-8 text-center text-gray-400 text-xs">
                        ÊÖ∂Á•ù30Âë®Âπ¥Ê†°ÊÖ∂Ê¥ªÂãïÂ∞àÁî®
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
