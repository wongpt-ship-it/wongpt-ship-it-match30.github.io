<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #d8d4c7; /* Softer, slightly vintage background */
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden; /* Prevent body scroll */
        }
        
        .stick-shadow {
            /* Soft centered shadow */
            filter: drop-shadow(0px 2px 2px rgba(0,0,0,0.25));
        }
        
        /* Dashed slot styling */
        .slot-dash {
            border: 2px dashed rgba(0,0,0,0.15);
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }

        /* Paper texture overlay */
        .paper-texture {
            background-image: radial-gradient(#a39e93 1px, transparent 1px);
            background-size: 20px 20px;
            opacity: 0.15;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Helpers ---
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        // --- Configuration (CENTER BASED) ---

        // Grid Unit: Digit Box approx 100x180
        // Coordinates represent the CENTER of the stick (80x10)
        
        const SEGMENT_CENTERS = [
            [50, 10, 0],   // 0: Top (Horizontal)
            [10, 50, 90],  // 1: Top-Left (Vertical)
            [90, 50, 90],  // 2: Top-Right (Vertical)
            [50, 90, 0],   // 3: Middle (Horizontal)
            [10, 130, 90], // 4: Bot-Left (Vertical)
            [90, 130, 90], // 5: Bot-Right (Vertical)
            [50, 170, 0]   // 6: Bottom (Horizontal)
        ];

        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] 
        };

        // Operators (Centers)
        // Plus: Perfect cross at (50, 90)
        const OP_PLUS = [
            [50, 90, 90], // Vertical
            [50, 90, 0]   // Horizontal
        ];
        const OP_MINUS = [[50, 90, 0]];
        const OP_EQUAL = [[50, 75, 0], [50, 105, 0]]; // Gap 30px

        // --- VALIDATION HELPER ---
        const checkMath = (values, ops) => {
            if (values.length === 3 && ops.length === 1) {
                const res = ops[0] === '+' ? values[0] + values[1] : values[0] - values[1];
                return res === values[2];
            } 
            return false;
        };

        // --- POOLS ---

        const POOL_MATH = [
            {
                id: 'm1', type: 'math', title: "ç†±èº«é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 5 = 8",
                hint1: "8 ä¸éœ€è¦è®Šå‹•ï¼Œè©¦è‘—æ”¹è®Šå…¶ä¸­ä¸€å€‹ 5ã€‚", hint2: "æŠŠç¬¬ä¸€å€‹ 5 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 3ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm2', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 + 3 = 6",
                hint1: "å˜—è©¦æŠŠ 9 è®Šå°ã€‚", hint2: "æŠŠ 9 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ° 6 çš„ç¼ºå£ï¼Œè®“å®ƒè®Šæˆ 8ã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 3, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 6, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm3', type: 'math', title: "ç¶“å…¸é¡Œ", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "6 + 4 = 4",
                hint1: "é€™é¡Œæœ‰å¤šå€‹è§£æ³•ï¼è©¦è©¦æŠŠåŠ è™Ÿè®Šæ¸›è™Ÿï¼Ÿ", hint2: "è§£æ³•ä¸€ï¼š8 - 4 = 4ã€‚è§£æ³•äºŒï¼š0 + 4 = 4ã€‚",
                layout: [{ type: 'digit', value: 6, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 4, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 4, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm4', type: 'math', title: "æ•¸å­—è®Šèº«", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "9 - 5 = 8", 
                hint1: "æ¸›æ³•è®ŠåŠ æ³•ï¼Ÿ", hint2: "æŠŠ 9 è®Šæˆ 3ï¼Œæ¸›è™Ÿè®ŠåŠ è™Ÿã€‚",
                layout: [{ type: 'digit', value: 9, x: 0 }, { type: 'op', value: '-', x: 130 }, { type: 'digit', value: 5, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 8, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm5', type: 'math', title: "æ¸›æ³•æŒ‘æˆ°", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "5 + 7 = 2",
                hint1: "åŠ æ³•è®Šæ¸›æ³•ï¼Ÿ", hint2: "æŠŠåŠ è™Ÿçš„ä¸€æ ¹ç«æŸ´ç§»åˆ° 5 ä¸Šï¼Œè®“å®ƒè®Šæˆ 9ã€‚",
                layout: [{ type: 'digit', value: 5, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 7, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 2, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            },
            {
                id: 'm6', type: 'math', title: "åŠ æ¸›æ³•", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "3 + 6 = 3",
                hint1: "è©¦è©¦çœ‹ 3 åŠ  0ã€‚", hint2: "æŠŠ 6 è®Šæˆ 0ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'op', value: '+', x: 130 }, { type: 'digit', value: 6, x: 230 }, { type: 'op', value: '=', x: 360 }, { type: 'digit', value: 3, x: 460 }],
                check: (values, ops) => checkMath(values, ops)
            }
        ];

        // Shapes (Legacy Top-Left Coords need conversion to Center)
        const DIAG = 56; 
        const SL = 80;
        
        // Helper to convert legacy pivot based coords to centers
        // Old Logic: x,y is top-left pivot (5,5).
        // New Logic: cx, cy is center.
        // Vector from Pivot(5,5) to Center(40,5) is (35, 0).
        const toCenter = (item) => {
            const rad = item.r * Math.PI / 180;
            return {
                x: item.x + 5 + 35 * Math.cos(rad),
                y: item.y + 5 + 35 * Math.sin(rad),
                r: item.r
            };
        };

        const POOL_SHAPE = [
            {
                id: 's1', type: 'shape', title: "æ¸¸å‹•çš„å°é­š", instruction: "ç§»å‹• 3 æ ¹ç«æŸ´ï¼Œè®“é­šå‘åæ–¹å‘æ¸¸",
                formula: "åœ–å½¢é¡Œ",
                hint1: "é­šé ­ç¾åœ¨å‘å·¦ï¼Œè¦æŠŠå®ƒè®Šå‘å³ã€‚", hint2: "ç§»å‹•é­šé°­å’Œä¸‹åŠéƒ¨çš„èº«é«”ã€‚",
                customSticks: [
                    {x:400, y:100, r:45}, {x:400+DIAG, y:100+DIAG, r:135}, 
                    {x:400, y:100+2*DIAG, r:225}, {x:400-DIAG, y:100+DIAG, r:315},
                    {x:400+DIAG, y:100+DIAG, r:315}, {x:400+DIAG, y:100+DIAG, r:45},  
                    {x:400, y:100, r:225}, {x:400, y:100+2*DIAG, r:135}  
                ],
                winSlots: [
                    {x:400, y:100, r:45}, {x:400+DIAG, y:100+DIAG, r:135}, {x:400, y:100+2*DIAG, r:225}, {x:344, y:156, r:315},
                    {x:400-DIAG, y:100+DIAG, r:225}, {x:400-DIAG, y:100+DIAG, r:135}, 
                    {x:400, y:100, r:315}, {x:400, y:100+2*DIAG, r:45}   
                ],
                validSlots: [
                    {x:400-DIAG, y:100+DIAG, r:225}, {x:400-DIAG, y:100+DIAG, r:135},
                    {x:400+DIAG, y:100+DIAG, r:315}, {x:400+DIAG, y:100+DIAG, r:45},
                    {x:400, y:100, r:225}, {x:400, y:100, r:315},
                    {x:400, y:100+2*DIAG, r:135}, {x:400, y:100+2*DIAG, r:45}
                ]
            },
            {
                id: 's2', type: 'shape', title: "å…©å€‹ç®­é ­", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠå…©å€‹ç®­é ­è®Šæˆä¸€å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "å°‡å…©å€‹ç®­é ­çš„å°¾éƒ¨é€£èµ·ä¾†ã€‚", hint2: "é€™æ˜¯ä¸€å€‹è¦–éŒ¯è¦ºï¼Œä¸éœ€è¦å®Œç¾çš„æ­£æ–¹å½¢ï¼Œé•·æ–¹å½¢(Box)ä¹Ÿå¯ä»¥ã€‚",
                customSticks: [
                    {x:200, y:100, r:45}, {x:200, y:100+2*DIAG, r:315},
                    {x:200+SL, y:100, r:45}, {x:200+SL, y:100+2*DIAG, r:315} 
                ],
                winSlots: [
                   {x:200+DIAG/2, y:100+DIAG/2, r:0}, {x:200+DIAG/2, y:100+1.5*DIAG, r:0},
                   {x:200, y:100+DIAG, r:90}, {x:200+SL, y:100+DIAG, r:90}
                ],
                validSlots: [
                    {x:200+DIAG/2, y:100+DIAG/2, r:0}, {x:200+DIAG/2, y:100+1.5*DIAG, r:0},
                    {x:200, y:100+DIAG, r:90}, {x:200+SL, y:100+DIAG, r:90},
                    {x:200, y:100, r:45}, {x:200, y:100+2*DIAG, r:315},
                    {x:200+SL, y:100, r:45}, {x:200+SL, y:100+2*DIAG, r:315}
                ]
            },
            {
                id: 's3', type: 'shape', title: "ä¸‰å€‹æ­£æ–¹å½¢", instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼ŒæŠŠä¸‰å€‹æ­£æ–¹å½¢è®Šæˆå…©å€‹æ­£æ–¹å½¢",
                formula: "åœ–å½¢é¡Œ",
                hint1: "è©¦è‘—æŠŠä¸­é–“çš„æ­£æ–¹å½¢æ‹†æ‰ã€‚", hint2: "æŠŠä¸­é–“æ­£æ–¹å½¢çš„å…©æ ¹ç›´ç«æŸ´æ‹¿èµ°ï¼Œæ”¾åˆ°å“ªè£¡å‘¢ï¼Ÿè£œä¸Šç¼ºå£ã€‚",
                customSticks: [
                    {x:100, y:100, r:0}, {x:180, y:100, r:0}, {x:260, y:100, r:0},
                    {x:100, y:180, r:0}, {x:180, y:180, r:0}, {x:260, y:180, r:0},
                    {x:100, y:100, r:90}, {x:180, y:100, r:90}, {x:260, y:100, r:90}, {x:340, y:100, r:90}
                ],
                winSlots: [
                    {x:100, y:100, r:0}, {x:100, y:180, r:0}, {x:100, y:100, r:90}, {x:180, y:100, r:90},
                    {x:340, y:100, r:0}, {x:340, y:180, r:0}, {x:340, y:100, r:90}, {x:420, y:100, r:90}
                ],
                validSlots: [
                   {x:100, y:100, r:0}, {x:180, y:100, r:0}, {x:260, y:100, r:0}, {x:340, y:100, r:0},
                   {x:100, y:180, r:0}, {x:180, y:180, r:0}, {x:260, y:180, r:0}, {x:340, y:180, r:0},
                   {x:100, y:100, r:90}, {x:180, y:100, r:90}, {x:260, y:100, r:90}, {x:340, y:100, r:90}, {x:420, y:100, r:90}
                ]
            }
        ];

        const POOL_SPECIAL = [
            {
                id: 'sp1', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸€)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "26 + 4 = 20",
                hint1: "æŠŠç­”æ¡ˆ 20 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 20 çš„å·¦ä¸‹è§’ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 2, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 4, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 2, x: 510 }, { type: 'digit', value: 0, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) + values[2] === 30
            },
            {
                id: 'sp2', type: 'math', title: "ä¸‰åè€Œç«‹ (äºŒ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "36 - 6 = 36",
                hint1: "æŠŠç­”æ¡ˆ 36 è®Šæˆ 30ã€‚", hint2: "ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 6, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 6, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 'sp3', type: 'math', title: "ä¸‰åè€Œç«‹ (ä¸‰)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "35 - 5 = 39",
                hint1: "35 æ¸› 5 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 39 çš„ 9 è®Šæˆ 0ã€‚ç§»å‹• 9 çš„ä¸­é–“ç«æŸ´åˆ°å·¦ä¸‹è§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 5, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 9, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp4', type: 'math', title: "ä¸‰åè€Œç«‹ (å››)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹", formula: "39 - 9 = 36",
                hint1: "39 æ¸› 9 ç­‰æ–¼ 30ã€‚", hint2: "æŠŠçµæœ 36 çš„ 6 è®Šæˆ 0ã€‚ç§»å‹• 6 çš„ä¸­é–“ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 3, x: 0 }, { type: 'digit', value: 9, x: 100 }, { type: 'op', value: '-', x: 220 }, { type: 'digit', value: 9, x: 310 }, { type: 'op', value: '=', x: 430 }, { type: 'digit', value: 3, x: 510 }, { type: 'digit', value: 6, x: 610 }],
                check: (values) => values.length === 5 && (values[0]*10 + values[1]) - values[2] === (values[3]*10 + values[4])
            },
            {
                id: 'sp5', type: 'math', title: "ä¸‰åé€±å¹´ (çµ‚æ¥µ)", instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30", formula: "15 + 15 = 50",
                hint1: "15 + 15 æ‡‰è©²æ˜¯ 30ã€‚", hint2: "æŠŠ 50 çš„ 5 è®Šæˆ 3ã€‚ç§»å‹•å·¦ä¸Šè§’çš„ç«æŸ´åˆ°å³ä¸Šè§’ã€‚",
                layout: [{ type: 'digit', value: 1, x: 0 }, { type: 'digit', value: 5, x: 100 }, { type: 'op', value: '+', x: 220 }, { type: 'digit', value: 1, x: 310 }, { type: 'digit', value: 5, x: 410 }, { type: 'op', value: '=', x: 530 }, { type: 'digit', value: 5, x: 610 }, { type: 'digit', value: 0, x: 710 }],
                check: (values) => values.length === 6 && (values[0]*10 + values[1]) + (values[2]*10 + values[3]) === 30
            }
        ];

        const generateLevelSet = () => {
            const math = shuffleArray(POOL_MATH).slice(0, 4);
            const shape = shuffleArray(POOL_SHAPE).slice(0, 2);
            const special = shuffleArray(POOL_SPECIAL).slice(0, 4);
            return [...math, ...shape, ...special];
        };

        const calculateBounds = (items) => {
            // Simplified bounds for center-based items
            // Just assume radius 40px around center
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            items.forEach(item => {
                minX = Math.min(minX, item.x - 40);
                maxX = Math.max(maxX, item.x + 40);
                minY = Math.min(minY, item.y - 40);
                maxY = Math.max(maxY, item.y + 40);
            });
            return { minX, maxX, minY, maxY };
        };

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = [];
            let idCounter = 0;
            
            let rawItems = [];
            
            // Helper to add item
            const addItem = (x, y, r, type, extra={}) => {
                rawItems.push({ x, y, r, type, ...extra });
            };

            if (levelData.type === 'shape') {
                // Convert Shape coords to Centers
                levelData.customSticks.forEach(s => {
                    const center = toCenter(s);
                    addItem(center.x, center.y, center.r, 'stick');
                    addItem(center.x, center.y, center.r, 'slot');
                });
                if (levelData.validSlots) {
                    levelData.validSlots.forEach(s => {
                        const center = toCenter(s);
                        addItem(center.x, center.y, center.r, 'slot');
                    });
                }
            } else {
                levelData.layout.forEach((part, partIndex) => {
                    let baseX = part.x; 
                    let baseY = 0; 
                    if (part.type === 'digit') {
                        SEGMENT_CENTERS.forEach((pos, segIndex) => {
                            const [lx, ly, lr] = pos;
                            const cx = baseX + lx;
                            const cy = baseY + ly;
                            addItem(cx, cy, lr, 'slot', { partIndex, segmentIndex: segIndex });
                            if (DIGIT_MAP[part.value].includes(segIndex)) {
                                addItem(cx, cy, lr, 'stick');
                            }
                        });
                    } else if (part.type === 'op') {
                        const ops = part.value === '=' ? OP_EQUAL : (part.value === '-' ? OP_MINUS : OP_PLUS);
                        // ops contains centers [x, y, r] relative to digit box
                        ops.forEach((pos, segIndex) => {
                            const [lx, ly, lr] = pos;
                            const cx = baseX + lx;
                            const cy = baseY + ly;
                            
                            // For Plus/Minus, add alternative slots
                            if (part.value !== '=') {
                                OP_PLUS.forEach((p, idx) => {
                                    const [px, py, pr] = p;
                                    addItem(baseX + px, baseY + py, pr, 'slot', { partIndex, opType: idx===0?'vert':'horiz' });
                                });
                            } else {
                                addItem(cx, cy, lr, 'slot', { partIndex });
                            }

                            // Add Sticks
                            // Plus: Both. Minus: Horiz only.
                            if (part.value === '+' || part.value === '=' || (part.value === '-' && segIndex === 0)) {
                                addItem(cx, cy, lr, 'stick');
                            }
                        });
                    }
                });
            }

            const bounds = calculateBounds(rawItems);
            const contentW = bounds.maxX - bounds.minX;
            const contentH = bounds.maxY - bounds.minY;
            const containerW = 800;
            const containerH = 320;
            // Round shift to integer
            const shiftX = Math.round((containerW - contentW) / 2 - bounds.minX);
            const shiftY = Math.round((containerH - contentH) / 2 - bounds.minY);

            // Final Generation
            // Use Sets to dedup slots based on integer coordinates
            const slotMap = new Map();

            rawItems.forEach(item => {
                const finalX = Math.round(item.x + shiftX);
                const finalY = Math.round(item.y + shiftY);
                
                if (item.type === 'slot') {
                    const key = `${finalX},${finalY},${item.r}`;
                    if (!slotMap.has(key)) {
                        const sId = `slot_${idCounter++}`;
                        const slotObj = { id: sId, x: finalX, y: finalY, r: item.r, ...item };
                        slotMap.set(key, slotObj);
                        slots.push(slotObj);
                    }
                }
            });

            // Re-loop for sticks to find matching slots
            rawItems.forEach(item => {
                if (item.type === 'stick') {
                    const finalX = Math.round(item.x + shiftX);
                    const finalY = Math.round(item.y + shiftY);
                    const key = `${finalX},${finalY},${item.r}`;
                    
                    // For shapes, we might need a specific slot, but for center-based math it matches geometry
                    let matchId = null;
                    if (slotMap.has(key)) {
                        matchId = slotMap.get(key).id;
                    } else {
                        // Fallback if stick exists without slot (rare with this logic)
                        // Create hidden slot?
                    }

                    sticks.push({
                        id: `stick_${idCounter++}`,
                        slotId: matchId, 
                        x: finalX, 
                        y: finalY, 
                        rotation: item.r, 
                        color: 'bg-orange-600'
                    });
                }
            });

            return { sticks, slots, shiftX, shiftY };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown }) => (
            <div onMouseDown={onMouseDown} onTouchStart={onMouseDown}
                style={{
                    position: 'absolute', 
                    left: x, top: y, 
                    width: '80px', height: '10px',
                    backgroundColor: isDragging ? '#fbbf24' : '#d97706', 
                    borderRadius: '5px',
                    transform: `translate(-50%, -50%) rotate(${rotation}deg)`, 
                    cursor: 'pointer',
                    zIndex: isDragging ? 50 : 10, 
                    touchAction: 'none'
                }}
                className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
            >
                <div style={{ width: '12px', height: '14px', backgroundColor: '#ef4444', borderRadius: '50%', position: 'absolute', left: '-2px', top: '-2px' }}></div>
                <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
            </div>
        );

        const Slot = ({ x, y, rotation, isShape }) => (
            <div className={isShape ? "slot-dash" : "bg-black/5"}
                style={{
                    position: 'absolute', 
                    left: x, top: y, 
                    width: '80px', height: '10px',
                    borderRadius: '5px', 
                    transform: `translate(-50%, -50%) rotate(${rotation}deg)`, 
                    zIndex: 1
                }}
            ></div>
        );

        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing');
            const [hintLevel, setHintLevel] = useState(0);
            const [boardScale, setBoardScale] = useState(1);
            const [levels, setLevels] = useState([]);
            const [offsets, setOffsets] = useState({x:0, y:0});

            const boardRef = useRef(null);
            const gameAreaRef = useRef(null);

            useEffect(() => {
                setLevels(generateLevelSet());
            }, []);

            const currentLevel = levels.length > 0 ? levels[currentLevelIdx] : null;

            useEffect(() => {
                if (currentLevel) loadLevelData(currentLevel);
            }, [currentLevel]);

            useEffect(() => {
                const handleResize = () => {
                    const w = window.innerWidth;
                    setBoardScale(Math.min(1, (w - 32) / 800));
                };
                handleResize();
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const loadLevelData = (levelData) => {
                const { sticks: initSticks, slots: initSlots, shiftX, shiftY } = generateSticks(levelData);
                setSticks(initSticks);
                setSlots(initSlots);
                setOffsets({x: shiftX, y: shiftY});
                setMovesCount(0);
                setGameState('playing');
                setHintLevel(0);
            };

            const handleMove = (e) => {
                if (!draggingId || !boardRef.current) return;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const rect = boardRef.current.getBoundingClientRect();
                const scale = rect.width / 800;
                setMousePos({ x: (clientX - rect.left) / scale - dragOffset.x, y: (clientY - rect.top) / scale - dragOffset.y });
            };
            const handleUp = () => {
                if (draggingId) { snapStick(draggingId, mousePos.x, mousePos.y); setDraggingId(null); }
            };
            useEffect(() => {
                window.addEventListener('mousemove', handleMove); window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false }); window.addEventListener('touchend', handleUp);
                return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); window.removeEventListener('touchmove', handleMove); window.removeEventListener('touchend', handleUp); };
            }, [draggingId, mousePos, dragOffset]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                if (boardRef.current) {
                    const rect = boardRef.current.getBoundingClientRect();
                    const scale = rect.width / 800;
                    setDragOffset({ x: (clientX - rect.left) / scale - stickX, y: (clientY - rect.top) / scale - stickY });
                    setMousePos({ x: stickX, y: stickY });
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                let nearest = null, minDist = 50;
                const currentStick = sticks.find(s => s.id === stickId);
                slots.forEach(slot => {
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    if (dist < minDist && !isOccupied) { minDist = dist; nearest = slot; }
                });

                if (nearest) {
                    const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id, rotation: nearest.r } : s);
                    if(currentStick.slotId !== nearest.id) setMovesCount(p => p + 1);
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    // Return to original slot logic?
                    // With Center logic, we need to find the slot that matches original slotId
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) setSticks(sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s));
                }
            };

            const checkWinCondition = (currentSticks) => {
                if (!currentLevel) return;

                if (currentLevel.type === 'shape') {
                    const required = currentLevel.winSlots.length;
                    let matchCount = 0;
                    
                    // Convert Win Slots to Center coords + Shift
                    // We need a helper to check if a stick is near a win slot (converted)
                    
                    currentLevel.winSlots.forEach(wsLegacy => {
                        const wsCenter = toCenter(wsLegacy);
                        const targetX = Math.round(wsCenter.x + offsets.x);
                        const targetY = Math.round(wsCenter.y + offsets.y);
                        
                        const hasStick = currentSticks.some(s => 
                            Math.abs(s.x - targetX) < 15 && 
                            Math.abs(s.y - targetY) < 15 &&
                            Math.abs(s.rotation - wsCenter.r) < 10
                        );
                        if (hasStick) matchCount++;
                    });

                    if (matchCount >= required && currentSticks.length === required) {
                        setGameState('won');
                        new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                    }

                } else {
                    const filledSlots = {};
                    currentSticks.forEach(s => {
                        const slot = slots.find(sl => sl.id === s.slotId);
                        if (slot) {
                            if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                            if (slot.opType === 'vert') filledSlots[slot.partIndex].push('vert');
                            else if (slot.opType === 'horiz') filledSlots[slot.partIndex].push('horiz');
                            else filledSlots[slot.partIndex].push(slot.segmentIndex);
                        }
                    });

                    const decodedValues = [], decodedOps = [];
                    let isMalformed = false;

                    currentLevel.layout.forEach((part, idx) => {
                        const segments = filledSlots[idx] || [];
                        if (part.type === 'digit') {
                            let digit = -1;
                            Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                                const a = [...val].sort(), b = [...segments].sort();
                                if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                            });
                            if (digit !== -1) decodedValues.push(digit); else isMalformed = true;
                        } else if (part.type === 'op') {
                            if (part.value === '=') { if (segments.length !== 2) isMalformed = true; }
                            else {
                                const hasVert = segments.includes('vert'), hasHoriz = segments.includes('horiz');
                                if (hasVert && hasHoriz) decodedOps.push('+');
                                else if (!hasVert && hasHoriz) decodedOps.push('-');
                                else isMalformed = true;
                            }
                        }
                    });

                    if (!isMalformed) {
                        try {
                            if (currentLevel.check(decodedValues, decodedOps)) {
                                setGameState('won');
                                new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg').play().catch(e=>{});
                            }
                        } catch (e) {}
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < levels.length - 1) setCurrentLevelIdx(p => p + 1);
                else {
                    alert("æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰é—œå¡ï¼30é€±å¹´å¿«æ¨‚ï¼");
                    setLevels(generateLevelSet());
                    setCurrentLevelIdx(0);
                }
            };

            const resetLevel = () => { if(currentLevel) loadLevelData(currentLevel); };

            if (!currentLevel) return <div className="flex h-screen items-center justify-center text-2xl text-orange-600 font-bold">è¼‰å…¥ä¸­...</div>;

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 w-full max-w-4xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-4 bg-white/80 backdrop-blur p-4 rounded-xl shadow-lg border-b-4 border-orange-300">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-700 tracking-wider">ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</h1>
                            <div className="flex items-center gap-2 mt-2">
                                <span className="bg-orange-100 text-orange-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">é—œå¡ {currentLevelIdx + 1}/{levels.length}</span>
                                {currentLevel.id.startsWith('sp') && <span className="bg-red-100 text-red-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm animate-pulse">30é€±å¹´ç‰¹åˆ¥é¡Œ</span>}
                                {currentLevel.type === 'shape' && <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm font-bold shadow-sm">åœ–å½¢æŒ‘æˆ°</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-xs font-bold uppercase tracking-widest">ç§»å‹•æ¬¡æ•¸</div>
                            <div className="text-3xl font-black text-gray-700">{movesCount}</div>
                        </div>
                    </div>

                    <div className={`border-l-8 p-6 mb-6 w-full rounded-lg shadow-md ${currentLevel.type === 'shape' ? 'bg-blue-50 border-blue-400 text-blue-900' : 'bg-[#fcf8e3] border-yellow-400 text-yellow-800'}`}>
                        <div className="text-lg font-bold mb-1">{currentLevel.title}</div>
                        <div className="text-xl mb-2">{currentLevel.instruction}</div>
                        <div className="text-2xl font-mono bg-white/50 inline-block px-4 py-2 rounded border shadow-inner tracking-widest opacity-80">
                            {currentLevel.formula}
                        </div>
                    </div>

                    <div ref={gameAreaRef} className="relative bg-[#eeeadd] rounded-xl shadow-inner border-4 border-[#d1cbb8] w-full overflow-hidden" style={{ height: '320px', touchAction: 'none' }}>
                        <div className="absolute inset-0 paper-texture"></div>
                        <div ref={boardRef} className="absolute top-[50px] left-1/2 w-[800px] h-[200px] origin-top" style={{ transform: `translateX(-50%) scale(${boardScale})` }}>
                            {slots.map(slot => ( <Slot key={slot.id} x={slot.x} y={slot.y} rotation={slot.r} isShape={currentLevel.type === 'shape'} /> ))}
                            {sticks.map(stick => ( <Stick key={stick.id} x={draggingId === stick.id ? mousePos.x : stick.x} y={draggingId === stick.id ? mousePos.y : stick.y} rotation={stick.rotation} isDragging={draggingId === stick.id} onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)} /> ))}
                        </div>
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-b-8 border-green-500 transform scale-110">
                                    <div className="text-7xl mb-4 float-anim">ğŸ‰</div>
                                    <h2 className="text-4xl font-black text-green-600 mb-2 tracking-tight">ç­”æ¡ˆæ­£ç¢ºï¼</h2>
                                    <button onClick={nextLevel} className="bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-10 rounded-full text-2xl shadow-lg transform transition hover:scale-105 active:scale-95 flex items-center gap-3 mx-auto">ä¸‹ä¸€é—œ âœ</button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow-lg border border-gray-100">
                            <div className="flex justify-between items-center mb-3">
                                <h3 className="font-bold text-gray-700 flex items-center gap-2"><span className="text-xl">ğŸ’¡</span> æç¤º</h3>
                                <div className="flex gap-2">
                                    <button onClick={() => setHintLevel(1)} disabled={hintLevel >= 1 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 1 ? 'bg-gray-100 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}>LV 1</button>
                                    <button onClick={() => setHintLevel(2)} disabled={hintLevel >= 2 || gameState === 'won'} className={`px-4 py-1.5 rounded-full text-xs font-bold transition ${hintLevel >= 2 ? 'bg-gray-100 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}>LV 2</button>
                                </div>
                            </div>
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-4 rounded-lg border border-gray-100 leading-relaxed">
                                {hintLevel === 0 && "å¦‚æœåœ¨è§£é¡Œæ™‚é‡åˆ°å›°é›£ï¼Œå¯ä»¥æŒ‰ä¸Šæ–¹æŒ‰éˆ•ç²å¾—æç¤ºã€‚"}
                                {hintLevel >= 1 && (<div className="animate-pulse text-blue-700 font-medium mb-2 flex items-start gap-2"><span>ğŸ”¹</span> {currentLevel.hint1}</div>)}
                                {hintLevel >= 2 && (<div className="text-purple-700 font-bold flex items-start gap-2"><span>ğŸ”¸</span> {currentLevel.hint2}</div>)}
                            </div>
                        </div>
                        <div className="flex flex-col gap-3">
                            <button onClick={resetLevel} className="flex-1 bg-white hover:bg-gray-50 text-gray-700 font-bold py-3 rounded-xl border-b-4 border-gray-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">ğŸ”„ é‡ç½®æœ¬é—œ</button>
                            <button onClick={nextLevel} className="flex-1 bg-red-50 hover:bg-red-100 text-red-600 font-bold py-3 rounded-xl border-b-4 border-red-200 active:border-b-0 active:translate-y-1 transition flex items-center justify-center gap-2 shadow-sm">â© è·³éæœ¬é—œ</button>
                        </div>
                    </div>
                </div>
            );
        };
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
