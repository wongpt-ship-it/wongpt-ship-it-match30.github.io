<!DOCTYPE html>
<html lang="zh-HK">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Google Fonts for a playful look -->
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;600&display=swap" rel="stylesheet">
    
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            touch-action: none; /* Prevent scrolling on iPad while dragging */
            background-color: #fef3c7;
            user-select: none;
            -webkit-user-select: none;
            overflow: hidden; /* Prevent body scroll */
        }
        
        .stick-shadow {
            filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.3));
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        .float-anim {
            animation: float 3s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Data & Configuration ---

        const DIGIT_MAP = {
            0: [0, 1, 2, 4, 5, 6],
            1: [2, 5],
            2: [0, 2, 3, 4, 6],
            3: [0, 2, 3, 5, 6],
            4: [1, 2, 3, 5],
            5: [0, 1, 3, 5, 6],
            6: [0, 1, 3, 4, 5, 6],
            7: [0, 2, 5],
            8: [0, 1, 2, 3, 4, 5, 6],
            9: [0, 1, 2, 3, 5, 6] 
        };

        const SEGMENT_POSITIONS = [
            [20, 0, 0],   // 0: Top
            [10, 20, 90], // 1: Top-Left
            [90, 20, 90], // 2: Top-Right
            [20, 80, 0],  // 3: Middle
            [10, 100, 90],// 4: Bottom-Left
            [90, 100, 90],// 5: Bottom-Right
            [20, 160, 0]  // 6: Bottom
        ];

        const OP_PLUS = [
            [40, 50, 90], // Vertical
            [10, 80, 0]   // Horizontal
        ];
        
        const OP_MINUS = [
            [10, 80, 0]
        ];

        const OP_EQUAL = [
            [10, 65, 0],
            [10, 95, 0]
        ];

        const LEVELS = [
            {
                id: 1,
                title: "ç†±èº«é¡Œ",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "5 + 5 = 8",
                hint1: "8 ä¸éœ€è¦è®Šå‹•ï¼Œè©¦è‘—æ”¹è®Šå…¶ä¸­ä¸€å€‹ 5ã€‚",
                hint2: "æŠŠç¬¬ä¸€å€‹ 5 çš„å·¦ä¸Šè§’ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 3ã€‚",
                layout: [
                    { type: 'digit', value: 5, x: 0 },
                    { type: 'op', value: '+', x: 130 },
                    { type: 'digit', value: 5, x: 230 },
                    { type: 'op', value: '=', x: 360 },
                    { type: 'digit', value: 8, x: 460 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] 
            },
            {
                id: 2,
                title: "åŠ æ¸›æ³•",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "3 + 3 = 8",
                hint1: "8 å¾ˆå¤§ï¼Œä¸éœ€è¦è®Šå‹•ã€‚å˜—è©¦æŠŠå…¶ä¸­ä¸€å€‹ 3 è®Šå¤§ã€‚",
                hint2: "æŠŠç¬¬ä¸€å€‹ 3 çš„å³ä¸Šè§’ç«æŸ´ç§»åˆ°å·¦ä¸Šè§’ï¼Œè®Šæˆ 5ã€‚",
                layout: [
                    { type: 'digit', value: 3, x: 0 },
                    { type: 'op', value: '+', x: 130 },
                    { type: 'digit', value: 3, x: 230 },
                    { type: 'op', value: '=', x: 360 },
                    { type: 'digit', value: 8, x: 460 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] 
            },
            {
                id: 3,
                title: "æ¸›æ³•æŒ‘æˆ°",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "5 + 7 = 2",
                hint1: "åŠ æ³•è®Šæ¸›æ³•ï¼Ÿ",
                hint2: "æŠŠåŠ è™Ÿçš„ä¸€æ ¹ç«æŸ´ç§»åˆ° 5 ä¸Šï¼Œè®“å®ƒè®Šæˆ 9ã€‚",
                layout: [
                    { type: 'digit', value: 5, x: 0 },
                    { type: 'op', value: '+', x: 130 },
                    { type: 'digit', value: 7, x: 230 },
                    { type: 'op', value: '=', x: 360 },
                    { type: 'digit', value: 2, x: 460 }
                ],
                maxMoves: 1,
                check: (values, ops) => values[0] - values[2] === values[4]
            },
            {
                id: 4,
                title: "æ•¸å­—è®Šèº«",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "9 + 3 = 6", 
                hint1: "çµæœ 6 ä¼¼ä¹å°‘äº†ä¸€æ ¹ç«æŸ´ã€‚",
                hint2: "æŠŠåŠ è™Ÿçš„ä¸€æ ¹ç«æŸ´ç§»åˆ° 6 ä¸Šï¼Œè®Šæˆ 8ï¼Œä¸¦è®“é‹ç®—è®Šæˆæ¸›æ³•ã€‚",
                layout: [
                    { type: 'digit', value: 9, x: 0 },
                    { type: 'op', value: '+', x: 130 },
                    { type: 'digit', value: 3, x: 230 },
                    { type: 'op', value: '=', x: 360 },
                    { type: 'digit', value: 6, x: 460 }
                ],
                maxMoves: 1,
                check: (values) => values[0] - values[2] === values[4] 
            },
            {
                id: 5,
                title: "ç„¡ä¸­ç”Ÿæœ‰",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "3 + 9 = 6",
                hint1: "è©¦è‘—æŠŠ 9 è®Šæˆ 5ã€‚",
                hint2: "æŠŠ 9 çš„å³ä¸Šè§’ç«æŸ´ç§»åˆ° 6 çš„ç¼ºå£ï¼Œè®Šæˆ 8ã€‚",
                layout: [
                    { type: 'digit', value: 3, x: 0 },
                    { type: 'op', value: '+', x: 130 },
                    { type: 'digit', value: 9, x: 230 },
                    { type: 'op', value: '=', x: 360 },
                    { type: 'digit', value: 6, x: 460 }
                ],
                maxMoves: 1,
                check: (values) => values[0] + values[2] === values[4] 
            },
            // --- 30th Anniversary Levels ---
            {
                id: 6,
                title: "ä¸‰åè€Œç«‹ (ä¸€)",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30",
                formula: "26 + 4 = 20",
                hint1: "é¡Œç›®è¦æ±‚çµæœæ˜¯ 30ï¼Œçœ‹çœ‹ç­”æ¡ˆéƒ¨åˆ†ã€‚",
                hint2: "æŠŠç­”æ¡ˆ 20 çš„ 2 è®Šæˆ 3ã€‚ç§»å‹•å·¦ä¸‹è§’çš„ç«æŸ´åˆ°å³ä¸‹è§’ã€‚",
                layout: [
                    { type: 'digit', value: 2, x: 0 },
                    { type: 'digit', value: 6, x: 80 },
                    { type: 'op', value: '+', x: 190 },
                    { type: 'digit', value: 4, x: 270 },
                    { type: 'op', value: '=', x: 380 },
                    { type: 'digit', value: 2, x: 480 },
                    { type: 'digit', value: 0, x: 560 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) + values[2] === 30 
            },
            {
                id: 7,
                title: "ä¸‰åè€Œç«‹ (äºŒ)",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿çµæœç­‰æ–¼ 30",
                formula: "36 - 6 = 36",
                hint1: "36 æ¸› 6 æ‡‰è©²ç­‰æ–¼å¤šå°‘ï¼Ÿ",
                hint2: "æŠŠç­”æ¡ˆ 36 çš„ 6 ä¸­é–“é‚£æ ¹ç«æŸ´ç§»åˆ°å³ä¸Šè§’ï¼Œè®Šæˆ 0ã€‚",
                layout: [
                    { type: 'digit', value: 3, x: 0 },
                    { type: 'digit', value: 6, x: 80 },
                    { type: 'op', value: '-', x: 190 },
                    { type: 'digit', value: 6, x: 270 },
                    { type: 'op', value: '=', x: 380 },
                    { type: 'digit', value: 3, x: 480 },
                    { type: 'digit', value: 6, x: 560 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 8,
                title: "ä¸‰åè€Œç«‹ (ä¸‰)",
                instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼Œåšå‡º 30",
                formula: "35 - 5 = 39",
                hint1: "35 æ¸› 5 æ‡‰è©²æ˜¯ 30ã€‚",
                hint2: "æŠŠ 39 çš„ 9 è®Šæˆ 0ã€‚ç§»å‹•ä¸­é–“çš„ç«æŸ´åˆ°å·¦ä¸‹è§’ã€‚",
                layout: [
                    { type: 'digit', value: 3, x: 0 },
                    { type: 'digit', value: 5, x: 80 },
                    { type: 'op', value: '-', x: 190 },
                    { type: 'digit', value: 5, x: 270 },
                    { type: 'op', value: '=', x: 380 },
                    { type: 'digit', value: 3, x: 480 },
                    { type: 'digit', value: 9, x: 560 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 9,
                title: "ä¸‰åé€±å¹´ (å››)",
                instruction: "ç§»å‹• 1 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "39 - 9 = 36", 
                hint1: "é€™æ˜¯ä¸€æ¢ç°¡å–®çš„æ¸›æ³•ã€‚",
                hint2: "æŠŠ 36 çš„ 6 è®Šæˆ 0ã€‚",
                layout: [
                    { type: 'digit', value: 3, x: 0 },
                    { type: 'digit', value: 9, x: 80 },
                    { type: 'op', value: '-', x: 190 },
                    { type: 'digit', value: 9, x: 270 },
                    { type: 'op', value: '=', x: 380 },
                    { type: 'digit', value: 3, x: 480 },
                    { type: 'digit', value: 6, x: 560 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) - values[2] === 30
            },
            {
                id: 10,
                title: "ä¸‰åé€±å¹´ (çµ‚æ¥µ)",
                instruction: "ç§»å‹• 2 æ ¹ç«æŸ´ï¼Œä½¿ç­‰å¼æˆç«‹",
                formula: "11 + 19 = 80",
                hint1: "15 åŠ  15 ç­‰æ–¼å¤šå°‘ï¼Ÿ",
                hint2: "æŠŠç­”æ¡ˆ 50 çš„ 5 è®Šæˆ 3ã€‚å°‡å·¦ä¸Šè§’çš„ç«æŸ´ç§»åˆ°å³ä¸Šè§’ã€‚",
                layout: [
                    { type: 'digit', value: 1, x: 0 },
                    { type: 'digit', value: 5, x: 80 },
                    { type: 'op', value: '+', x: 190 },
                    { type: 'digit', value: 1, x: 270 },
                    { type: 'digit', value: 5, x: 350 },
                    { type: 'op', value: '=', x: 460 },
                    { type: 'digit', value: 5, x: 560 },
                    { type: 'digit', value: 0, x: 640 }
                ],
                maxMoves: 1,
                check: (values) => (values[0]*10 + values[1]) + (values[2]*10 + values[3]) === 30
            }
        ];

        // --- Helpers ---

        const generateSticks = (levelData) => {
            let sticks = [];
            let slots = []; 
            let idCounter = 0;

            // --- Auto Centering Logic ---
            let minX = Infinity;
            let maxX = -Infinity;
            
            levelData.layout.forEach(part => {
                if (part.x < minX) minX = part.x;
                const width = part.type === 'digit' ? 110 : 80; 
                if (part.x + width > maxX) maxX = part.x + width;
            });

            const contentWidth = maxX - minX;
            const containerWidth = 800; 
            const startOffset = (containerWidth - contentWidth) / 2;
            const shiftX = startOffset - minX;
            // -----------------------------

            levelData.layout.forEach((part, partIndex) => {
                let baseX = part.x + shiftX; 
                let baseY = 30; // UPDATED: Move higher (was 100) to prevent bottom cutoff
                
                if (part.type === 'digit') {
                    SEGMENT_POSITIONS.forEach((pos, segIndex) => {
                        const slotId = `slot_${partIndex}_${segIndex}`;
                        const isPresent = DIGIT_MAP[part.value].includes(segIndex);
                        
                        slots.push({
                            id: slotId,
                            x: baseX + pos[0],
                            y: baseY + pos[1],
                            rotation: pos[2],
                            partIndex: partIndex,
                            segmentIndex: segIndex 
                        });

                        if (isPresent) {
                            sticks.push({
                                id: `stick_${idCounter++}`,
                                slotId: slotId,
                                x: baseX + pos[0],
                                y: baseY + pos[1],
                                rotation: pos[2],
                                color: 'bg-orange-600'
                            });
                        }
                    });
                } else if (part.type === 'op') {
                    if (part.value === '+' || part.value === '-') {
                         OP_PLUS.forEach((pos, segIndex) => {
                            // Vert slot
                            slots.push({
                                id: `slot_${partIndex}_vert`,
                                x: baseX + 40, y: baseY + 50, rotation: 90,
                                partIndex, type: 'plus_vert'
                            });
                            // Horiz slot
                            slots.push({
                                id: `slot_${partIndex}_horiz`,
                                x: baseX + 10, y: baseY + 80, rotation: 0,
                                partIndex, type: 'plus_horiz'
                            });

                            // Add sticks
                            if (part.value === '+') {
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_vert`, x: baseX + 40, y: baseY + 50, rotation: 90 });
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_horiz`, x: baseX + 10, y: baseY + 80, rotation: 0 });
                            } else {
                                sticks.push({ id: `stick_${idCounter++}`, slotId: `slot_${partIndex}_horiz`, x: baseX + 10, y: baseY + 80, rotation: 0 });
                            }
                        });
                    } else {
                        // Equal sign
                         OP_EQUAL.forEach((pos, segIndex) => {
                             const slotId = `slot_${partIndex}_${segIndex}`;
                             slots.push({
                                 id: slotId,
                                 x: baseX + pos[0],
                                 y: baseY + pos[1],
                                 rotation: pos[2],
                                 partIndex
                             });
                             sticks.push({
                                 id: `stick_${idCounter++}`,
                                 slotId: slotId,
                                 x: baseX + pos[0],
                                 y: baseY + pos[1],
                                 rotation: pos[2]
                             });
                         });
                    }
                }
            });
            slots = slots.filter((v,i,a)=>a.findIndex(t=>(t.id === v.id))===i);
            return { sticks, slots };
        };

        const Stick = ({ x, y, rotation, isDragging, onMouseDown, color }) => {
            return (
                <div
                    onMouseDown={onMouseDown}
                    onTouchStart={onMouseDown}
                    style={{
                        position: 'absolute',
                        left: x,
                        top: y,
                        width: '80px',
                        height: '10px',
                        backgroundColor: isDragging ? '#fbbf24' : '#d97706',
                        borderRadius: '5px',
                        transform: `rotate(${rotation}deg)`,
                        transformOrigin: '5px 5px',
                        cursor: 'pointer',
                        zIndex: isDragging ? 50 : 10,
                        touchAction: 'none'
                    }}
                    className={`flex items-center ${isDragging ? 'shadow-2xl scale-110' : 'stick-shadow'} transition-transform duration-100`}
                >
                    <div style={{
                        width: '12px',
                        height: '14px',
                        backgroundColor: '#ef4444',
                        borderRadius: '50%',
                        position: 'absolute',
                        left: '-2px',
                        top: '-2px'
                    }}></div>
                    <div className="w-full h-full opacity-30 bg-black/10 rounded-full"></div>
                </div>
            );
        };

        const Slot = ({ x, y, rotation }) => {
            return (
                <div
                    style={{
                        position: 'absolute',
                        left: x,
                        top: y,
                        width: '80px',
                        height: '10px',
                        backgroundColor: 'rgba(0,0,0,0.05)',
                        borderRadius: '5px',
                        transform: `rotate(${rotation}deg)`,
                        transformOrigin: '5px 5px',
                        zIndex: 1
                    }}
                ></div>
            );
        };

        const App = () => {
            const [currentLevelIdx, setCurrentLevelIdx] = useState(0);
            const [sticks, setSticks] = useState([]);
            const [slots, setSlots] = useState([]);
            const [draggingId, setDraggingId] = useState(null);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });
            const [mousePos, setMousePos] = useState({ x: 0, y: 0 });
            const [movesCount, setMovesCount] = useState(0);
            const [gameState, setGameState] = useState('playing'); 
            const [hintLevel, setHintLevel] = useState(0); 
            const [boardScale, setBoardScale] = useState(1); // Dynamic scale state
            
            const boardRef = useRef(null); 
            const gameAreaRef = useRef(null); 

            const currentLevel = LEVELS[currentLevelIdx];

            useEffect(() => {
                loadLevel(currentLevelIdx);
            }, [currentLevelIdx]);

            // UPDATED: Dynamic scaling logic
            useEffect(() => {
                const handleResize = () => {
                    const w = window.innerWidth;
                    // Logic container width is 800px.
                    // If screen is smaller than 800px (plus margin), scale down.
                    // Max scale limited to 1.
                    const newScale = Math.min(1, (w - 32) / 800);
                    setBoardScale(newScale);
                };
                
                handleResize(); // Initial calc
                window.addEventListener('resize', handleResize);
                return () => window.removeEventListener('resize', handleResize);
            }, []);

            const loadLevel = (idx) => {
                const { sticks: initSticks, slots: initSlots } = generateSticks(LEVELS[idx]);
                setSticks(initSticks);
                setSlots(initSlots);
                setMovesCount(0);
                setGameState('playing');
                setHintLevel(0);
            };

            useEffect(() => {
                const handleMove = (e) => {
                    if (!draggingId || !boardRef.current) return;
                    
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                    // IMPORTANT: Use the current state scale for calculation
                    const rect = boardRef.current.getBoundingClientRect();
                    // We can verify scale from rect if we want, but using state is cleaner for logic if synced
                    // Actually, rect.width / 800 is the most accurate reflection of current render
                    const currentScale = rect.width / 800;

                    // Map mouse to internal coordinate system
                    const mouseX = (clientX - rect.left) / currentScale;
                    const mouseY = (clientY - rect.top) / currentScale;

                    setMousePos({
                        x: mouseX - dragOffset.x,
                        y: mouseY - dragOffset.y
                    });
                };

                const handleUp = () => {
                    if (draggingId) {
                        snapStick(draggingId, mousePos.x, mousePos.y);
                        setDraggingId(null);
                    }
                };

                window.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleUp);
                window.addEventListener('touchmove', handleMove, { passive: false });
                window.addEventListener('touchend', handleUp);

                return () => {
                    window.removeEventListener('mousemove', handleMove);
                    window.removeEventListener('mouseup', handleUp);
                    window.removeEventListener('touchmove', handleMove);
                    window.removeEventListener('touchend', handleUp);
                };
            }, [draggingId, mousePos, dragOffset, slots]);

            const startDrag = (e, stickId, stickX, stickY) => {
                if (gameState === 'won') return;
                e.preventDefault();
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                
                if (boardRef.current) {
                    const rect = boardRef.current.getBoundingClientRect();
                    const scale = rect.width / 800;
                    
                    // Map mouse click to internal coordinates to calculate offset
                    const mouseX = (clientX - rect.left) / scale;
                    const mouseY = (clientY - rect.top) / scale;
                    
                    setDragOffset({ x: mouseX - stickX, y: mouseY - stickY });
                    setMousePos({ x: stickX, y: stickY });
                    setDraggingId(stickId);
                }
            };

            const snapStick = (stickId, x, y) => {
                let nearest = null;
                let minDist = 50; 

                const currentStick = sticks.find(s => s.id === stickId);
                
                slots.forEach(slot => {
                    const dist = Math.sqrt(Math.pow(slot.x - x, 2) + Math.pow(slot.y - y, 2));
                    const isOccupied = sticks.some(s => s.slotId === slot.id && s.id !== stickId);
                    const rotDiff = Math.abs(currentStick.rotation - slot.rotation);
                    const isRotMatch = rotDiff < 10 || rotDiff > 350; 

                    if (dist < minDist && !isOccupied && isRotMatch) {
                        minDist = dist;
                        nearest = slot;
                    }
                });

                if (nearest) {
                    const newSticks = sticks.map(s => {
                        if (s.id === stickId) {
                            if (s.slotId !== nearest.id) {
                                setMovesCount(prev => prev + 1);
                            }
                            return { ...s, x: nearest.x, y: nearest.y, slotId: nearest.id };
                        }
                        return s;
                    });
                    setSticks(newSticks);
                    checkWinCondition(newSticks);
                } else {
                    const originalSlot = slots.find(s => s.id === currentStick.slotId);
                    if (originalSlot) {
                        const newSticks = sticks.map(s => s.id === stickId ? { ...s, x: originalSlot.x, y: originalSlot.y } : s);
                        setSticks(newSticks);
                    }
                }
            };

            const checkWinCondition = (currentSticks) => {
                const filledSlots = {}; 
                
                currentSticks.forEach(s => {
                    const slot = slots.find(sl => sl.id === s.slotId);
                    if (slot) {
                        if (!filledSlots[slot.partIndex]) filledSlots[slot.partIndex] = [];
                        
                        if (slot.type === 'plus_vert') filledSlots[slot.partIndex].push('vert');
                        else if (slot.type === 'plus_horiz') filledSlots[slot.partIndex].push('horiz');
                        else filledSlots[slot.partIndex].push(slot.segmentIndex);
                    }
                });

                const decodedValues = [];
                const decodedOps = []; 
                let isMalformed = false;

                currentLevel.layout.forEach((part, idx) => {
                    const segments = filledSlots[idx] || [];
                    
                    if (part.type === 'digit') {
                        let digit = -1;
                        Object.entries(DIGIT_MAP).forEach(([key, val]) => {
                            const a = [...val].sort();
                            const b = [...segments].sort();
                            if (JSON.stringify(a) === JSON.stringify(b)) digit = parseInt(key);
                        });
                        if (digit !== -1) decodedValues.push(digit);
                        else isMalformed = true;
                    } else if (part.type === 'op') {
                        if (part.value === '=') {
                            if (segments.length === 2) { /* ok */ }
                            else isMalformed = true; 
                        } else {
                            const hasVert = segments.includes('vert');
                            const hasHoriz = segments.includes('horiz');
                            
                            if (hasVert && hasHoriz) decodedOps.push('+');
                            else if (!hasVert && hasHoriz) decodedOps.push('-');
                            else isMalformed = true;
                        }
                    }
                });

                if (!isMalformed) {
                    try {
                        if (currentLevel.check(decodedValues, decodedOps)) {
                            setGameState('won');
                            const audio = new Audio('https://actions.google.com/sounds/v1/cartoon/magic_chime.ogg');
                            audio.volume = 0.5;
                            audio.play().catch(e=>{});
                        }
                    } catch (e) {
                    }
                }
            };

            const nextLevel = () => {
                if (currentLevelIdx < LEVELS.length - 1) {
                    setCurrentLevelIdx(prev => prev + 1);
                } else {
                    alert("æ­å–œï¼ä½ å·²å®Œæˆæ‰€æœ‰é—œå¡ï¼30é€±å¹´å¿«æ¨‚ï¼");
                    setCurrentLevelIdx(0);
                }
            };

            return (
                <div className="min-h-screen flex flex-col items-center py-6 px-2 w-full max-w-4xl mx-auto">
                    <div className="w-full flex justify-between items-center mb-4 bg-white p-4 rounded-xl shadow-lg border-2 border-orange-200">
                        <div>
                            <h1 className="text-2xl md:text-3xl font-bold text-orange-600">ä¸‰åé€±å¹´ï¼šç«æŸ´æ™ºå¤šæ˜Ÿ</h1>
                            <div className="flex items-center gap-2 mt-1">
                                <span className="bg-orange-100 text-orange-800 px-2 py-1 rounded text-sm font-bold">é—œå¡ {currentLevelIdx + 1}/10</span>
                                {currentLevelIdx >= 5 && <span className="bg-red-100 text-red-800 px-2 py-1 rounded text-sm font-bold">30é€±å¹´ç‰¹åˆ¥é¡Œ</span>}
                            </div>
                        </div>
                        <div className="text-right">
                            <div className="text-gray-500 text-sm">ç§»å‹•æ¬¡æ•¸</div>
                            <div className="text-2xl font-bold text-gray-700">{movesCount}</div>
                        </div>
                    </div>

                    <div className="bg-yellow-100 border-l-4 border-yellow-500 text-yellow-700 p-4 mb-4 w-full rounded shadow-sm">
                        <p className="font-bold">{currentLevel.title}</p>
                        <p>{currentLevel.instruction}</p>
                        <p className="text-sm mt-1 text-gray-500 font-mono">{currentLevel.formula}</p>
                    </div>

                    <div 
                        ref={gameAreaRef}
                        className="relative bg-white rounded-xl shadow-inner border-4 border-orange-300 w-full overflow-hidden"
                        style={{ height: '300px', touchAction: 'none' }} 
                    >
                        <div className="absolute inset-0 opacity-10" 
                            style={{backgroundImage: 'radial-gradient(#fbbf24 1px, transparent 1px)', backgroundSize: '20px 20px'}}>
                        </div>

                        {/* UPDATED: Dynamic scale applied via style transform to ensure horizontal fit */}
                        <div 
                            ref={boardRef}
                            className="absolute top-[50px] left-1/2 w-[800px] h-[200px] origin-top"
                            style={{ transform: `translateX(-50%) scale(${boardScale})` }}
                        >
                            {slots.map(slot => (
                                <Slot key={slot.id} {...slot} />
                            ))}

                            {sticks.map(stick => (
                                <Stick 
                                    key={stick.id}
                                    x={draggingId === stick.id ? mousePos.x : stick.x}
                                    y={draggingId === stick.id ? mousePos.y : stick.y}
                                    rotation={stick.rotation}
                                    isDragging={draggingId === stick.id}
                                    onMouseDown={(e) => startDrag(e, stick.id, stick.x, stick.y)}
                                />
                            ))}
                        </div>
                        
                        {gameState === 'won' && (
                            <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-black/60 backdrop-blur-sm animate-fade-in">
                                <div className="bg-white p-8 rounded-2xl shadow-2xl text-center border-4 border-green-500 transform scale-110">
                                    <div className="text-6xl mb-4 float-anim">ğŸ‰</div>
                                    <h2 className="text-3xl font-bold text-green-600 mb-2">ç­”æ¡ˆæ­£ç¢ºï¼</h2>
                                    <p className="text-gray-600 mb-6">å¤ªå²å®³äº†ï¼</p>
                                    <button 
                                        onClick={nextLevel}
                                        className="bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full text-xl shadow-lg transform transition hover:scale-105 active:scale-95"
                                    >
                                        ä¸‹ä¸€é—œ
                                    </button>
                                </div>
                            </div>
                        )}
                    </div>

                    <div className="w-full mt-6 grid grid-cols-2 gap-4">
                        <div className="bg-white p-4 rounded-xl shadow border border-gray-200">
                            <div className="flex justify-between items-center mb-2">
                                <h3 className="font-bold text-gray-700">ğŸ’¡ æç¤º</h3>
                                <div className="space-x-2">
                                    <button 
                                        onClick={() => setHintLevel(1)}
                                        disabled={hintLevel >= 1 || gameState === 'won'}
                                        className={`px-3 py-1 rounded text-sm font-bold transition ${hintLevel >= 1 ? 'bg-gray-200 text-gray-400' : 'bg-blue-100 text-blue-600 hover:bg-blue-200'}`}
                                    >
                                        æç¤º I
                                    </button>
                                    <button 
                                        onClick={() => setHintLevel(2)}
                                        disabled={hintLevel >= 2 || gameState === 'won'}
                                        className={`px-3 py-1 rounded text-sm font-bold transition ${hintLevel >= 2 ? 'bg-gray-200 text-gray-400' : 'bg-purple-100 text-purple-600 hover:bg-purple-200'}`}
                                    >
                                        æç¤º II
                                    </button>
                                </div>
                            </div>
                            
                            <div className="min-h-[3rem] text-sm text-gray-600 bg-gray-50 p-3 rounded">
                                {hintLevel === 0 && "å¦‚æœåœ¨è§£é¡Œæ™‚é‡åˆ°å›°é›£ï¼Œå¯ä»¥æŒ‰ä¸Šæ–¹æŒ‰éˆ•ç²å¾—æç¤ºã€‚"}
                                {hintLevel >= 1 && (
                                    <div className="animate-pulse text-blue-800 font-medium mb-1">
                                        LV1: {currentLevel.hint1}
                                    </div>
                                )}
                                {hintLevel >= 2 && (
                                    <div className="text-purple-800 font-bold">
                                        LV2: {currentLevel.hint2}
                                    </div>
                                )}
                            </div>
                        </div>

                        <div className="flex flex-col gap-2">
                            <button 
                                onClick={() => loadLevel(currentLevelIdx)}
                                className="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-700 font-bold py-3 rounded-xl border border-gray-300 transition flex items-center justify-center gap-2"
                            >
                                ğŸ”„ é‡ç½®æœ¬é—œ
                            </button>
                        </div>
                    </div>
                    
                    <div className="mt-8 text-center text-gray-400 text-xs">
                        æ…¶ç¥30é€±å¹´æ ¡æ…¶æ´»å‹•å°ˆç”¨
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
